// Cloudflare Worker برای سیستم فروش آزادی VPN با پنل وب مدیریت
const BOT_TOKEN = '8486172700:AAEHzmXgGE9DHKa0b76mQtR3O8Xp4gX_LuQ'; 
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
const ADMIN_ID = 6786448395;
const ADMIN_PASSWORD = 'matin778900';

// اطلاعات پرداخت
const PAYMENT_INFO = {
  cardNumber: '6037998221156739',
  cardHolder: 'مختاری',
  supportUsername: 'mykalikal'
};

// سرورهای پیش‌فرض
const DEFAULT_SERVERS = {
  'server_main': {
    id: 'server_main',
    name: 'سرور اصلی',
    baseUrl: 'https://pro.x2.goooooooozoooo.sbs',
    username: 'Hesamazadi',
    password: 'Hesamazadi123',
    isDefault: true,
    status: 'active',
    location: 'مولتی لوکیشن (بیش از 7 لوکیشن در یک سرویس)',
    description: 'سرور اصلی با پرسرعت بالا'
  }
};

// در DEFAULT_PLANS هر پلن باید order داشته باشه
const DEFAULT_PLANS = {
  'plan_1m_50gb': {
    id: 'plan_1m_50gb',
    name: '1 ماهه 50 گیگ',
    duration: 30,
    dataLimit: 50,
    price: 25000,
    description: 'مناسب برای استفاده عمومی',
    order: 1
  },
  'plan_1m_100gb': {
    id: 'plan_1m_100gb',
    name: '1 ماهه 100 گیگ', 
    duration: 30,
    dataLimit: 100,
    price: 45000,
    description: 'مناسب برای استفاده متوسط',
    order: 2
  },
  'plan_1m_unlimited': {
    id: 'plan_1m_unlimited',
    name: '1 ماهه نامحدود',
    duration: 30,
    dataLimit: 0,
    price: 75000,
    description: 'حجم نامحدود',
    order: 3
  },
  'plan_3m_unlimited': {
    id: 'plan_3m_unlimited',
    name: '3 ماهه نامحدود',
    duration: 90,
    dataLimit: 0,
    price: 200000,
    description: 'بهترین قیمت برای 3 ماه',
    order: 4
  }
};

// کلاس SafeKV بهبود یافته - مشکل 12 ساعته حل شده
class SafeKV {
  constructor(kv) {
    this.kv = kv;
    this.memoryStore = new Map();
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // کاهش به 5 دقیقه
    this.maxCacheSize = 200; // کاهش سایز cache
    this.maxMemorySize = 100; // کاهش memory store
    this.lastCleanup = Date.now();
    this.cleanupInterval = 30 * 60 * 1000; // افزایش فاصله cleanup به 30 دقیقه
    this.retryCount = 3;
    this.baseDelay = 1000;
  }

  cleanup() {
    const now = Date.now();
    
    // cleanup کمتر aggressive
    if (this.cache.size > this.maxCacheSize * 1.5) { // threshold بالاتر
      const entries = Array.from(this.cache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      // فقط نصف قدیمی‌ها رو پاک کن
      const toDelete = Math.floor(entries.length - this.maxCacheSize);
      for (let i = 0; i < toDelete; i++) {
        this.cache.delete(entries[i][0]);
      }
    }
    
    // فقط cache های خیلی قدیمی رو پاک کن
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.cacheTimeout * 2) { // دو برابر timeout
        this.cache.delete(key);
      }
    }
    
    this.lastCleanup = now;
  }

  async retryOperation(operation, retries = this.retryCount) {
    for (let i = 0; i < retries; i++) {
      try {
        return await operation();
      } catch (error) {
        console.error(`KV operation failed (attempt ${i + 1}/${retries}):`, error);
        
        if (i === retries - 1) {
          throw error;
        }
        
        // exponential backoff
        const delay = this.baseDelay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  async get(key, type = 'text') {
    // cleanup کمتر
    if (Date.now() - this.lastCleanup > this.cleanupInterval) {
      this.cleanup();
    }
    
    try {
      // برای service ها cache نکن یا کمتر cache کن
      const isServiceKey = key.includes('service_');
      const cacheKey = `${key}_${type}`;
      
      if (!isServiceKey) {
        const cachedItem = this.cache.get(cacheKey);
        if (cachedItem && Date.now() - cachedItem.timestamp < this.cacheTimeout) {
          return type === 'json' ? JSON.parse(cachedItem.value || 'null') : cachedItem.value;
        }
      }

      let value;
      if (this.kv) {
        value = await this.retryOperation(async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 20000); // timeout بیشتر
          
          try {
            const result = await this.kv.get(key, type);
            clearTimeout(timeoutId);
            return result;
          } catch (error) {
            clearTimeout(timeoutId);
            throw error;
          }
        });
      } else {
        const stored = this.memoryStore.get(key);
        value = type === 'json' ? JSON.parse(stored || 'null') : stored;
      }

      // فقط غیر service ها رو cache کن
      if (!isServiceKey && value !== null && value !== undefined) {
        if (this.cache.size >= this.maxCacheSize) {
          const firstKey = this.cache.keys().next().value;
          this.cache.delete(firstKey);
        }
        
        this.cache.set(cacheKey, {
          value: typeof value === 'string' ? value : JSON.stringify(value),
          timestamp: Date.now()
        });
      }

      return value;
    } catch (error) {
      console.error('KV get error:', error);
      
      // در صورت خطا cache رو پاک کن
      const cacheKey = `${key}_${type}`;
      this.cache.delete(cacheKey);
      
      // اگر service key هست و KV کار نمیکنه، null برگردون
      if (key.includes('service_')) {
        return null;
      }
      
      return null;
    }
  }

  async put(key, value) {
    try {
      const stringValue = typeof value === 'string' ? value : JSON.stringify(value);
      
      // cache رو فوری پاک کن
      const cacheKeys = Array.from(this.cache.keys()).filter(k => k.startsWith(key));
      cacheKeys.forEach(k => this.cache.delete(k));
      
      if (this.kv) {
        const result = await this.retryOperation(async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 25000); // timeout بیشتر
          
          try {
            const result = await this.kv.put(key, stringValue);
            clearTimeout(timeoutId);
            return result;
          } catch (error) {
            clearTimeout(timeoutId);
            throw error;
          }
        });
        return result;
      } else {
        if (this.memoryStore.size >= this.maxMemorySize) {
          const firstKey = this.memoryStore.keys().next().value;
          this.memoryStore.delete(firstKey);
        }
        this.memoryStore.set(key, stringValue);
        return true;
      }
    } catch (error) {
      console.error('KV put error:', error);
      return false;
    }
  }

  async delete(key) {
    try {
      // همه cache های مربوط به این key رو پاک کن
      const cacheKeys = Array.from(this.cache.keys()).filter(k => k.startsWith(key));
      cacheKeys.forEach(k => this.cache.delete(k));
      
      if (this.kv) {
        return await this.retryOperation(async () => {
          return await this.kv.delete(key);
        });
      } else {
        this.memoryStore.delete(key);
        return true;
      }
    } catch (error) {
      console.error('KV delete error:', error);
      return false;
    }
  }

  async list(prefix, limit = 1000) {
    try {
      if (this.kv) {
        return await this.retryOperation(async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000); // timeout بالا برای list
          
          try {
            const result = await this.kv.list({ prefix, limit });
            clearTimeout(timeoutId);
            return result;
          } catch (error) {
            clearTimeout(timeoutId);
            throw error;
          }
        });
      } else {
        const keys = Array.from(this.memoryStore.keys())
          .filter(key => key.startsWith(prefix))
          .slice(0, limit);
        return { keys: keys.map(name => ({ name })) };
      }
    } catch (error) {
      console.error('KV list error:', error);
      return { keys: [] };
    }
  }

  clearCache() {
    this.cache.clear();
    console.log('Cache cleared manually');
  }

  clearAll() {
    this.cache.clear();
    this.memoryStore.clear();
    console.log('All caches cleared');
  }

  // متد جدید برای clear کردن فقط service cache ها
  clearServiceCache() {
    const serviceKeys = Array.from(this.cache.keys()).filter(k => k.includes('service_'));
    serviceKeys.forEach(k => this.cache.delete(k));
    console.log(`Cleared ${serviceKeys.length} service cache entries`);
  }

  // متد جدید برای گرفتن آمار
  getStats() {
    return {
      cacheSize: this.cache.size,
      memoryStoreSize: this.memoryStore.size,
      lastCleanup: new Date(this.lastCleanup).toISOString()
    };
  }
}

// تابع دیباگ برای بررسی KV
async function debugKVServices(chatId, kv) {
  if (!isAdmin(chatId)) return;
  
  try {
    console.log('Starting KV services debug...');
    
    // گرفتن آمار KV
    const stats = kv.getStats();
    
    // تست مستقیم لیست سرویس‌ها
    const allServicesResult = await kv.list('service_');
    console.log('All services found:', allServicesResult.keys.length);
    
    // تست سرویس‌های کاربر خاص
    const userServicesResult = await kv.list(`service_${chatId}_`);
    console.log(`User ${chatId} services:`, userServicesResult.keys.length);
    
    // چک کردن چند سرویس
    const serviceDetails = [];
    for (const key of userServicesResult.keys.slice(0, 5)) {
      try {
        const service = await kv.get(key.name, 'json');
        serviceDetails.push({
          key: key.name,
          exists: !!service,
          serviceId: service?.serviceId,
          username: service?.username
        });
      } catch (e) {
        serviceDetails.push({
          key: key.name,
          exists: false,
          error: e.message
        });
      }
    }
    
    const debugText = `🔍 <b>Debug KV Services</b>

📊 <b>آمار KV:</b>
• Cache Size: ${stats.cacheSize}
• Memory Store: ${stats.memoryStoreSize}  
• Last Cleanup: ${stats.lastCleanup}

📋 <b>سرویس‌ها:</b>
• کل سرویس‌ها: ${allServicesResult.keys.length}
• سرویس‌های شما: ${userServicesResult.keys.length}

🔍 <b>جزئیات نمونه:</b>
${serviceDetails.map(s => `• ${s.key}: ${s.exists ? '✅' : '❌'} ${s.username || s.error || ''}`).join('\n')}

⏰ <b>زمان چک:</b> ${formatDateTime(Date.now())}`;

    const debugKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '🗑️ Clear Service Cache', callback_data: 'debug_clear_service_cache' },
            { text: '🔄 Clear All Cache', callback_data: 'debug_clear_all_cache' }
          ],
          [
            { text: '📱 نمایش سرویس‌ها', callback_data: 'my_services' }
          ],
          [
            { text: '🏠 منوی اصلی', callback_data: 'start' }
          ]
        ]
      }
    };

    await sendMessage(chatId, debugText, debugKeyboard);
    
  } catch (error) {
    console.error('Debug KV error:', error);
    await sendMessage(chatId, `❌ خطا در debug: ${error.message}`);
  }
}

// کلاس API مرزبان با بهینه‌سازی سرعت
class MarzbanAPI {
  constructor(baseUrl, token = null) {
    this.baseUrl = baseUrl.replace(/\/$/, '');
    this.token = token;
    this.apiPath = '/api';
    this.requestQueue = [];
    this.processing = false;
  }

  async request(endpoint, options = {}) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({ endpoint, options, resolve, reject });
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing || this.requestQueue.length === 0) return;
    
    this.processing = true;
    
    const batch = this.requestQueue.splice(0, 10); // افزایش به 10 درخواست همزمان
    
    const promises = batch.map(async ({ endpoint, options, resolve, reject }) => {
      try {
        const result = await this.makeRequest(endpoint, options);
        resolve(result);
      } catch (error) {
        reject(error);
      }
    });

    await Promise.allSettled(promises);
    
    this.processing = false;
    
    // ادامه پردازش در صورت وجود درخواست‌های دیگر
    if (this.requestQueue.length > 0) {
      setTimeout(() => this.processQueue(), 50); // کاهش تاخیر
    }
  }

// فقط این تابع رو جایگزین کن:
async makeRequest(endpoint, options = {}, retryCount = 0) {
  const url = `${this.baseUrl}${endpoint}`;
  const headers = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    ...options.headers
  };

  if (this.token) {
    headers['Authorization'] = `Bearer ${this.token}`;
  }

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // افزایش timeout

    const response = await fetch(url, {
      ...options,
      headers,
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    let data;
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      data = await response.json();
    } else {
      const text = await response.text();
      data = { message: text };
    }

    if (!response.ok) {
      let errorMessage = response.statusText;
      if (data.detail) {
        errorMessage = typeof data.detail === 'string' ? data.detail : JSON.stringify(data.detail);
      } else if (data.message) {
        errorMessage = typeof data.message === 'string' ? data.message : JSON.stringify(data.message);
      }
      throw new Error(`HTTP ${response.status}: ${errorMessage}`);
    }

    return { success: true, data };
  } catch (error) {
    console.error('Marzban API Error:', error);
    
    // Retry mechanism
    if (retryCount < 3 && (error.name === 'AbortError' || error.message.includes('timeout'))) {
      console.log(`Retrying request (${retryCount + 1}/3)`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
      return this.makeRequest(endpoint, options, retryCount + 1);
    }
    
    if (error.name === 'AbortError') {
      return { success: false, error: 'درخواست منقضی شد. لطفاً دوباره تلاش کنید.' };
    }
    return { success: false, error: error.message };
  }
}

  async login(username, password) {
    try {
      const result = await this.makeRequest(`${this.apiPath}/admin/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({ username, password })
      });

      if (result.success && result.data.access_token) {
        this.token = result.data.access_token;
        return { success: true, token: this.token };
      }

      return { success: false, error: result.error || 'Login failed' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async getUser(username) {
    return await this.request(`${this.apiPath}/user/${encodeURIComponent(username)}`);
  }

  async createUser(userData) {
    return await this.request(`${this.apiPath}/user`, {
      method: 'POST',
      body: JSON.stringify(userData)
    });
  }

  async modifyUser(username, userData) {
    return await this.request(`${this.apiPath}/user/${encodeURIComponent(username)}`, {
      method: 'PUT',
      body: JSON.stringify(userData)
    });
  }

  async deleteUser(username) {
    return await this.request(`${this.apiPath}/user/${encodeURIComponent(username)}`, {
      method: 'DELETE'
    });
  }

  async getUsers(offset = 0, limit = 100) {
    return await this.request(`${this.apiPath}/users?offset=${offset}&limit=${limit}`);
  }

  async getInbounds() {
    return await this.request(`${this.apiPath}/inbounds`);
  }

  async getSystemStats() {
    return await this.request(`${this.apiPath}/system`);
  }
}

// توابع کمکی با زمان ایران
function isAdmin(chatId) {
  return chatId === ADMIN_ID;
}

function formatPrice(price) {
  return new Intl.NumberFormat('fa-IR').format(price) + ' تومان';
}

function formatBytes(bytes) {
  if (!bytes || bytes === 0) return 'نامحدود';
  const gb = bytes / (1024 * 1024 * 1024);
  return gb.toFixed(1) + ' گیگابایت';
}

function formatDate(timestamp) {
  if (!timestamp) return 'نامشخص';
  const date = new Date(timestamp);
  return date.toLocaleDateString('fa-IR', {
    timeZone: 'Asia/Tehran',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  });
}

function formatDateTime(timestamp) {
  if (!timestamp) return 'نامشخص';
  const date = new Date(timestamp);
  return date.toLocaleString('fa-IR', {
    timeZone: 'Asia/Tehran',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
}

function generateUsername(chatId, planId) {
  const randomNumber = Math.random().toString().slice(2, 8); // 6 رقم تصادفی
  return `ARDISK-${randomNumber}`;
}

function generateOrderId() {
  return 'ORD_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 5);
}

function generateServerId() {
  return 'server_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 3);
}

function generatePlanId() {
  return 'plan_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 3);
}

function generateTicketId() {
  return 'TKT_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 3);
}

// تولید شناسه یکتا برای سرویس
function generateServiceId() {
  return Date.now().toString() + '_' + Math.random().toString(36).substr(2, 6);
}

// تولید شناسه یکتا برای شارژ کیف پول
function generateChargeId() {
  return 'CHG_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 5);
}

// تولید شناسه تراکنش
function generateTransactionId() {
  return 'TXN_' + Date.now().toString() + '_' + Math.random().toString(36).substr(2, 5);
}

// دریافت موجودی کیف پول
async function getWalletBalance(chatId, kv) {
  try {
    const balance = await kv.get(`wallet_balance_${chatId}`, 'json');
    return balance || 0;
  } catch (error) {
    return 0;
  }
}

// بروزرسانی موجودی کیف پول
async function updateWalletBalance(chatId, amount, kv) {
  try {
    const currentBalance = await getWalletBalance(chatId, kv);
    const newBalance = currentBalance + amount;
    await kv.put(`wallet_balance_${chatId}`, JSON.stringify(newBalance));
    return newBalance;
  } catch (error) {
    console.error('Error updating wallet balance:', error);
    return false;
  }
}

// ثبت تراکنش کیف پول
async function recordWalletTransaction(chatId, amount, type, description, kv) {
  try {
    const transactionId = generateTransactionId();
    const transaction = {
      id: transactionId,
      chatId: chatId,
      amount: amount,
      type: type, // 'charge', 'purchase', 'refund'
      description: description,
      timestamp: Date.now()
    };
    
    await kv.put(`wallet_transaction_${transactionId}`, JSON.stringify(transaction));
    return transactionId;
  } catch (error) {
    console.error('Error recording transaction:', error);
    return false;
  }
}

// دریافت سرورها
async function getServers(kv) {
  try {
    const servers = await kv.get('system_servers', 'json');
    return servers || DEFAULT_SERVERS;
  } catch (error) {
    return DEFAULT_SERVERS;
  }
}

// ذخیره سرورها
async function saveServers(kv, servers) {
  try {
    await kv.put('system_servers', JSON.stringify(servers));
    return true;
  } catch (error) {
    console.error('Error saving servers:', error);
    return false;
  }
}

// دریافت سرور پیش‌فرض
async function getDefaultServer(kv) {
  try {
    const servers = await getServers(kv);
    return Object.values(servers).find(server => server.isDefault) || Object.values(servers)[0];
  } catch (error) {
    return Object.values(DEFAULT_SERVERS)[0];
  }
}

// دریافت پلن‌ها
async function getPlans(kv) {
  try {
    const plans = await kv.get('sales_plans', 'json');
    return plans || DEFAULT_PLANS;
  } catch (error) {
    return DEFAULT_PLANS;
  }
}

// ذخیره پلن‌ها
async function savePlans(kv, plans) {
  try {
    await kv.put('sales_plans', JSON.stringify(plans));
    return true;
  } catch (error) {
    console.error('Error saving plans:', error);
    return false;
  }
}

// تابع برای گرفتن پلن‌های مرتب شده
function getSortedPlans(plans) {
  return Object.values(plans).sort((a, b) => (a.order || 999) - (b.order || 999));
}

// تابع برای تنظیم مجدد order پلن‌ها
async function reorderPlans(planId, direction, kv) {
  try {
    const plans = await getPlans(kv);
    const sortedPlans = getSortedPlans(plans);
    const currentIndex = sortedPlans.findIndex(p => p.id === planId);
    
    if (currentIndex === -1) {
      return { success: false, error: 'پلن یافت نشد' };
    }
    
    let newIndex;
    if (direction === 'up' && currentIndex > 0) {
      newIndex = currentIndex - 1;
    } else if (direction === 'down' && currentIndex < sortedPlans.length - 1) {
      newIndex = currentIndex + 1;
    } else {
      return { success: false, error: 'امکان جابجایی وجود ندارد' };
    }
    
    // تعویض order دو پلن
    const temp = sortedPlans[currentIndex].order;
    sortedPlans[currentIndex].order = sortedPlans[newIndex].order;
    sortedPlans[newIndex].order = temp;
    
    // بروزرسانی در دیتابیس
    plans[sortedPlans[currentIndex].id] = sortedPlans[currentIndex];
    plans[sortedPlans[newIndex].id] = sortedPlans[newIndex];
    
    await savePlans(kv, plans);
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// تابع برای اولیه‌سازی order پلن‌ها
async function initializePlanOrders(kv) {
  try {
    const plans = await getPlans(kv);
    let hasChanges = false;
    let orderIndex = 1;
    
    // اگر پلن‌ها order ندارن، بهشون order بده
    Object.values(plans).forEach(plan => {
      if (!plan.order) {
        plan.order = orderIndex++;
        hasChanges = true;
      }
    });
    
    if (hasChanges) {
      await savePlans(kv, plans);
      console.log('Plan orders initialized');
    }
    
    return { success: true };
  } catch (error) {
    console.error('Error initializing plan orders:', error);
    return { success: false, error: error.message };
  }
}

// دریافت تنظیمات اینباند
async function getInboundSettings(kv) {
  try {
    const settings = await kv.get('inbound_settings', 'json');
    return settings || { referenceUsername: null };
  } catch (error) {
    return { referenceUsername: null };
  }
}

// ذخیره تنظیمات اینباند
async function saveInboundSettings(kv, settings) {
  try {
    await kv.put('inbound_settings', JSON.stringify(settings));
    return true;
  } catch (error) {
    console.error('Error saving inbound settings:', error);
    return false;
  }
}

// پیدا کردن سرویس با شناسه
async function findServiceById(chatId, serviceId, kv) {
  try {
    console.log('Looking for service:', chatId, serviceId);
    
    // ابتدا با الگوی جدید بگردیم
    const directKey = `service_${chatId}_${serviceId}`;
    let serviceData = await kv.get(directKey, 'json');
    
    if (serviceData) {
      console.log('Found service with direct key:', directKey);
      return { key: directKey, data: serviceData };
    }

    // اگر پیدا نشد، در همه سرویس‌های کاربر بگردیم
    const userServicesResult = await kv.list(`service_${chatId}_`);
    
    for (const key of userServicesResult.keys) {
      const data = await kv.get(key.name, 'json');
      if (data && data.serviceId === serviceId) {
        console.log('Found service with search:', key.name);
        return { key: key.name, data: data };
      }
    }

    console.log('Service not found');
    return null;
  } catch (error) {
    console.error('Error finding service:', error);
    return null;
  }
}

// پیدا کردن سرویس با نام کاربری
async function findServiceByUsername(chatId, username, kv) {
  try {
    console.log('Looking for service by username:', chatId, username);
    
    // جستجو در همه سرویس‌های کاربر
    const userServicesResult = await kv.list(`service_${chatId}_`);
    
    for (const key of userServicesResult.keys) {
      const data = await kv.get(key.name, 'json');
      if (data && data.username === username) {
        console.log('Found service by username:', key.name);
        return { key: key.name, data: data };
      }
    }

    console.log('Service not found by username');
    return null;
  } catch (error) {
    console.error('Error finding service by username:', error);
    return null;
  }
}

// بررسی انقضای سرویس‌ها و ارسال اطلاع‌رسانی - نسخه پیشرفته
async function checkExpiringServices(kv) {
  try {
    console.log('Starting advanced service expiry check...');
    const allServicesResult = await kv.list('service_');
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    const oneHourMs = 60 * 60 * 1000;
    
    for (const key of allServicesResult.keys) {
      const serviceData = await kv.get(key.name, 'json');
      if (!serviceData || serviceData.status !== 'active') continue;
      
      const timeUntilExpiry = serviceData.expireTimestamp - now;
      const hoursUntilExpiry = Math.ceil(timeUntilExpiry / oneHourMs);
      const daysUntilExpiry = Math.ceil(timeUntilExpiry / oneDayMs);
      
      // بررسی آخرین اطلاع‌رسانی
      const lastNotificationKey = `notification_${serviceData.chatId}_${serviceData.serviceId}`;
      const lastNotification = await kv.get(lastNotificationKey, 'json') || {};
      
      // اطلاع‌رسانی 1 روز قبل انقضا
      if (daysUntilExpiry === 1 && hoursUntilExpiry > 12 && !lastNotification.oneDayWarning) {
        await sendExpiryWarning(serviceData, 1, 'time', kv);
        lastNotification.oneDayWarning = now;
        await kv.put(lastNotificationKey, JSON.stringify(lastNotification));
      }
      
      // اطلاع‌رسانی 6 ساعت قبل انقضا
      if (hoursUntilExpiry <= 6 && hoursUntilExpiry > 0 && !lastNotification.sixHourWarning) {
        await sendExpiryWarning(serviceData, 0, 'time_critical', kv);
        lastNotification.sixHourWarning = now;
        await kv.put(lastNotificationKey, JSON.stringify(lastNotification));
      }
      
      // اطلاع‌رسانی انقضا
      if (daysUntilExpiry <= 0 && !lastNotification.expiredWarning) {
        await sendExpiryWarning(serviceData, 0, 'expired', kv);
        lastNotification.expiredWarning = now;
        await kv.put(lastNotificationKey, JSON.stringify(lastNotification));
      }

      // بررسی حجم ترافیک اگر سرویس محدود باشد
      if (serviceData.dataLimit && serviceData.dataLimit > 0) {
        await checkTrafficUsage(serviceData, lastNotification, lastNotificationKey, kv);
      }
    }
    
    console.log('Advanced expiry check completed');
  } catch (error) {
    console.error('Error in advanced expiry check:', error);
  }
}

// بررسی مصرف ترافیک سرویس
async function checkTrafficUsage(serviceData, lastNotification, notificationKey, kv) {
  try {
    const servers = await getServers(kv);
    const server = servers[serviceData.serverId];
    
    if (!server) return;

    const api = new MarzbanAPI(server.baseUrl);
    const loginResult = await api.login(server.username, server.password);
    
    if (!loginResult.success) return;

    const userResult = await api.getUser(serviceData.username);
    
    if (userResult.success && userResult.data) {
      const userData = userResult.data;
      const usedTraffic = userData.used_traffic || 0;
      const totalTraffic = userData.data_limit || (serviceData.dataLimit * 1024 * 1024 * 1024);
      
      if (totalTraffic > 0) {
        const usagePercent = (usedTraffic / totalTraffic) * 100;
        const now = Date.now();
        
        // اطلاع‌رسانی 80% مصرف
        if (usagePercent >= 80 && usagePercent < 95 && !lastNotification.traffic80Warning) {
          await sendTrafficWarning(serviceData, usagePercent, usedTraffic, totalTraffic, '80', kv);
          lastNotification.traffic80Warning = now;
          await kv.put(notificationKey, JSON.stringify(lastNotification));
        }
        
        // اطلاع‌رسانی 95% مصرف
        if (usagePercent >= 95 && usagePercent < 100 && !lastNotification.traffic95Warning) {
          await sendTrafficWarning(serviceData, usagePercent, usedTraffic, totalTraffic, '95', kv);
          lastNotification.traffic95Warning = now;
          await kv.put(notificationKey, JSON.stringify(lastNotification));
        }
        
        // اطلاع‌رسانی تمام شدن حجم
        if (usagePercent >= 100 && !lastNotification.trafficFinished) {
          await sendTrafficWarning(serviceData, 100, usedTraffic, totalTraffic, '100', kv);
          lastNotification.trafficFinished = now;
          await kv.put(notificationKey, JSON.stringify(lastNotification));
        }
      }
    }
  } catch (error) {
    console.error('Error checking traffic usage:', error);
  }
}

// ارسال اطلاع‌رسانی انقضا - بهبود یافته
async function sendExpiryWarning(serviceData, daysLeft, type, kv) {
  try {
    let warningText;
    let keyboardButtons;
    
    if (type === 'time_critical') {
      warningText = `🚨 <b>هشدار فوری انقضای سرویس</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
⏰ باقی‌مانده: کمتر از 6 ساعت
📅 انقضا: ${formatDate(serviceData.expireTimestamp)}

🔴 <b>فوری تمدید کنید!</b> سرویس شما به زودی قطع خواهد شد.

💡 <b>توجه:</b> بعد از انقضا دسترسی شما قطع می‌شود.`;

      keyboardButtons = [
        [{ text: '🔥 تمدید فوری', callback_data: `renew_service_${serviceData.serviceId}` }],
        [{ text: '📱 مدیریت سرویس', callback_data: `manage_service_${serviceData.serviceId}` }],
        [{ text: '💬 پشتیبانی فوری', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
      ];
    } else if (daysLeft === 1) {
      warningText = `⚠️ <b>یادآوری انقضای سرویس</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
⏰ باقی‌مانده: 1 روز
📅 انقضا: ${formatDate(serviceData.expireTimestamp)}

🔄 برای ادامه استفاده، سرویس خود را تمدید کنید.

💡 <b>نکته:</b> بعد از انقضا دسترسی شما قطع خواهد شد.`;

      keyboardButtons = [
        [{ text: '💎 تمدید سرویس', callback_data: `renew_service_${serviceData.serviceId}` }],
        [{ text: '📱 مدیریت سرویس', callback_data: `manage_service_${serviceData.serviceId}` }]
      ];
    } else {
      warningText = `❌ <b>سرویس منقضی شد</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📅 تاریخ انقضا: ${formatDate(serviceData.expireTimestamp)}

🚫 دسترسی شما قطع شده است.

🔄 برای بازگشت دسترسی، سرویس خود را تمدید کنید.`;

      keyboardButtons = [
        [{ text: '💎 تمدید فوری', callback_data: `renew_service_${serviceData.serviceId}` }],
        [{ text: '🛒 خرید سرویس جدید', callback_data: 'buy_service' }],
        [{ text: '💬 پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
      ];
    }

    const keyboard = {
      reply_markup: {
        inline_keyboard: keyboardButtons
      }
    };

    await sendMessage(serviceData.chatId, warningText, keyboard);
    
  } catch (error) {
    console.error('Error sending expiry warning:', error);
  }
}

// ارسال اطلاع‌رسانی حجم ترافیک
async function sendTrafficWarning(serviceData, usagePercent, usedTraffic, totalTraffic, level, kv) {
  try {
    let warningText;
    let keyboardButtons;
    
    if (level === '80') {
      warningText = `📊 <b>هشدار مصرف حجم</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📊 مصرف شده: ${formatBytes(usedTraffic)} از ${formatBytes(totalTraffic)}
💯 درصد مصرف: ${usagePercent.toFixed(1)}%

⚠️ <b>80% حجم شما مصرف شده!</b>

💡 توصیه می‌شود برای جلوگیری از قطعی، سرویس خود را تمدید کنید.`;

      keyboardButtons = [
        [{ text: '📊 مشاهده وضعیت', callback_data: `traffic_usage_${serviceData.serviceId}` }],
        [{ text: '💎 تمدید سرویس', callback_data: `renew_service_${serviceData.serviceId}` }]
      ];
    } else if (level === '95') {
      warningText = `🚨 <b>هشدار فوری مصرف حجم</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📊 مصرف شده: ${formatBytes(usedTraffic)} از ${formatBytes(totalTraffic)}
💯 درصد مصرف: ${usagePercent.toFixed(1)}%

🔴 <b>95% حجم شما مصرف شده!</b>

⚠️ برای جلوگیری از قطعی فوری تمدید کنید.`;

      keyboardButtons = [
        [{ text: '🔥 تمدید فوری', callback_data: `renew_service_${serviceData.serviceId}` }],
        [{ text: '💬 پشتیبانی فوری', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
      ];
    } else {
      warningText = `❌ <b>حجم سرویس تمام شد</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📊 مصرف شده: ${formatBytes(usedTraffic)}
💯 درصد مصرف: 100%

🚫 حجم سرویس شما تمام شده و دسترسی قطع شده است.

🔄 برای بازگشت دسترسی، سرویس خود را تمدید کنید.`;

      keyboardButtons = [
        [{ text: '💎 تمدید فوری', callback_data: `renew_service_${serviceData.serviceId}` }],
        [{ text: '🛒 خرید حجم اضافی', callback_data: 'buy_service' }],
        [{ text: '💬 پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
      ];
    }

    const keyboard = {
      reply_markup: {
        inline_keyboard: keyboardButtons
      }
    };

    await sendMessage(serviceData.chatId, warningText, keyboard);
    
  } catch (error) {
    console.error('Error sending traffic warning:', error);
  }
}

// در main keyboard
const KEYBOARDS = {
  main: {
    reply_markup: {
      inline_keyboard: [
        [
          { text: '🛒 خرید سرویس', callback_data: 'buy_service' },
          { text: '📱 سرویس‌های من', callback_data: 'my_services' }
        ],
        [
          { text: '💰 کیف پول', callback_data: 'wallet_menu' },
          { text: '🎫 پشتیبانی', callback_data: 'support_menu' }
        ],
        [
          { text: '📖 نحوه اتصال', callback_data: 'connection_guide' },
          { text: '👤 حساب کاربری', callback_data: 'user_account' }
        ],
        [
          { text: '🌐 ورود به پرتال مشتریان', web_app: { url: 'https://ardiskminiapp.matinder.workers.dev/' } }
        ]
      ]
    }
  },

  adminMain: {
    reply_markup: {
      inline_keyboard: [
        [
          { text: '🛒 خرید سرویس', callback_data: 'buy_service' },
          { text: '📱 سرویس‌های من', callback_data: 'my_services' }
        ],
        [
          { text: '💰 کیف پول', callback_data: 'wallet_menu' },
          { text: '🎫 پشتیبانی', callback_data: 'support_menu' }
        ],
        [
          { text: '📖 نحوه اتصال', callback_data: 'connection_guide' },
          { text: '👤 حساب کاربری', callback_data: 'user_account' }
        ],
        [
          { text: '🌐 ورود به پرتال مشتریان', web_app: { url: 'https://ardiskminiapp.matinder.workers.dev/' } }
        ],
        [
          { text: '⚙️ پنل مدیریت', callback_data: 'admin_panel' }
        ]
      ]
    }
  },

  supportMenu: {
    reply_markup: {
      inline_keyboard: [
        [
          { text: '🎫 ثبت تیکت جدید', callback_data: 'create_ticket' },
          { text: '📂 تیکت‌های من', callback_data: 'my_tickets' }
        ],
        [
          { text: '❓ سوالات متداول', callback_data: 'faq' }
        ],
        [
          { text: '🔙 منوی اصلی', callback_data: 'start' }
        ]
      ]
    }
  },

  walletMenu: {
    reply_markup: {
      inline_keyboard: [
        [
          { text: '💳 شارژ کیف پول', callback_data: 'wallet_charge' },
          { text: '📊 موجودی و تاریخچه', callback_data: 'wallet_balance' }
        ],
        [
          { text: '🔙 منوی اصلی', callback_data: 'start' }
        ]
      ]
    }
  },

  backToMain: {
    reply_markup: {
      inline_keyboard: [
        [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
      ]
    }
  },

  backToSupport: {
    reply_markup: {
      inline_keyboard: [
        [{ text: '🔙 منوی پشتیبانی', callback_data: 'support_menu' }]
      ]
    }
  },

  backToWallet: {
    reply_markup: {
      inline_keyboard: [
        [{ text: '🔙 کیف پول', callback_data: 'wallet_menu' }]
      ]
    }
  }
};

// ارسال پیام بهینه شده
async function sendMessage(chatId, text, options = {}) {
  try {
    const url = `${TELEGRAM_API}/sendMessage`;
    const payload = {
      chat_id: chatId,
      text: text,
      parse_mode: 'HTML',
      ...options
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    return await response.json();
  } catch (error) {
    console.error('Send message error:', error);
    return { ok: false, description: error.message };
  }
}

// ویرایش پیام بهینه شده
async function editMessage(chatId, messageId, text, options = {}) {
  try {
    const url = `${TELEGRAM_API}/editMessageText`;
    const payload = {
      chat_id: chatId,
      message_id: messageId,
      text: text,
      parse_mode: 'HTML',
      ...options
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    return await response.json();
  } catch (error) {
    console.error('Edit message error:', error);
    return { ok: false, description: error.message };
  }
}

// حذف پیام
async function deleteMessage(chatId, messageId) {
  try {
    const url = `${TELEGRAM_API}/deleteMessage`;
    const payload = {
      chat_id: chatId,
      message_id: messageId
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    return await response.json();
  } catch (error) {
    console.error('Delete message error:', error);
    return { ok: false, description: error.message };
  }
}

// ارسال عکس
async function sendPhoto(chatId, photoUrl, caption = '', options = {}) {
  try {
    const url = `${TELEGRAM_API}/sendPhoto`;
    const payload = {
      chat_id: chatId,
      photo: photoUrl,
      caption: caption,
      parse_mode: 'HTML',
      ...options
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    return await response.json();
  } catch (error) {
    console.error('Send photo error:', error);
    return { ok: false, description: error.message };
  }
}

// فوروارد پیام
async function forwardMessage(chatId, fromChatId, messageId) {
  try {
    const url = `${TELEGRAM_API}/forwardMessage`;
    const payload = {
      chat_id: chatId,
      from_chat_id: fromChatId,
      message_id: messageId
    };
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    return await response.json();
  } catch (error) {
    console.error('Forward message error:', error);
    return { ok: false, description: error.message };
  }
}

// نمایش منوی اصلی
async function showMainMenu(chatId, messageId = null, kv) {
  const welcomeText = `🛜 <b>ARDISK VPN
⬅️ به ربات آردیسک وی پی ان خوش آمدید!</b>

💎 ارائه فیلترشکن مولتی لوکیشن(بیش از 7 لوکیشن) پرسرعت
🔒 امنیت بسیار بالا و فضای رمزنگاری شده
🌍 دسترسی سریع و بدون قطعی به اینترنت آزاد
👨‍💻پشتیبانی: @mykalikal

🎯 <b>گزینه مورد نظر را انتخاب نمایید:</b>`;
  
  const keyboard = isAdmin(chatId) ? KEYBOARDS.adminMain : KEYBOARDS.main;
  
  if (messageId) {
    await editMessage(chatId, messageId, welcomeText, keyboard);
  } else {
    await sendMessage(chatId, welcomeText, keyboard);
  }
}

// نمایش منوی کیف پول
async function showWalletMenu(chatId, messageId, kv) {
  try {
    const balance = await getWalletBalance(chatId, kv);
    
    const walletText = `💰 <b>کیف پول من</b>

💳 <b>موجودی فعلی:</b> ${formatPrice(balance)}

🔧 <b>عملیات:</b>`;

    await editMessage(chatId, messageId, walletText, KEYBOARDS.walletMenu);

  } catch (error) {
    console.error('Error showing wallet menu:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش کیف پول.', KEYBOARDS.backToMain);
  }
}

// نمایش موجودی و تاریخچه کیف پول
async function showWalletBalance(chatId, messageId, kv) {
  try {
    const balance = await getWalletBalance(chatId, kv);
    
    // دریافت تاریخچه تراکنش‌ها
    const transactionsResult = await kv.list('wallet_transaction_');
    const userTransactions = [];
    
    for (const key of transactionsResult.keys) {
      const transaction = await kv.get(key.name, 'json');
      if (transaction && transaction.chatId === chatId) {
        userTransactions.push(transaction);
      }
    }
    
    userTransactions.sort((a, b) => b.timestamp - a.timestamp);
    const recentTransactions = userTransactions.slice(0, 10);
    
    let balanceText = `💰 <b>موجودی و تاریخچه کیف پول</b>

💳 <b>موجودی فعلی:</b> ${formatPrice(balance)}

📊 <b>آخرین تراکنش‌ها:</b>

`;

    if (recentTransactions.length === 0) {
      balanceText += '❌ هیچ تراکنشی یافت نشد';
    } else {
      recentTransactions.forEach((transaction, index) => {
        const typeEmoji = transaction.type === 'charge' ? '📈' : 
                         transaction.type === 'purchase' ? '📉' : '🔄';
        const typeText = transaction.type === 'charge' ? 'شارژ' :
                        transaction.type === 'purchase' ? 'خرید' : 'بازگشت';
        
        balanceText += `${index + 1}️⃣ ${typeEmoji} ${typeText}
💰 مبلغ: ${formatPrice(Math.abs(transaction.amount))}
📝 توضیح: ${transaction.description}
📅 تاریخ: ${formatDateTime(transaction.timestamp)}

`;
      });
    }

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '💳 شارژ کیف پول', callback_data: 'wallet_charge' }],
          [{ text: '🔙 کیف پول', callback_data: 'wallet_menu' }]
        ]
      }
    };

    await editMessage(chatId, messageId, balanceText, keyboard);

  } catch (error) {
    console.error('Error showing wallet balance:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش موجودی.', KEYBOARDS.backToWallet);
  }
}

// شارژ کیف پول
async function showWalletCharge(chatId, messageId, kv) {
  const chargeText = `💳 <b>شارژ کیف پول</b>

لطفاً مبلغ شارژ را بنویسید:

💡 <b>راهنما:</b>
• حداقل شارژ: 10,000 تومان
• حداکثر شارژ: 5,000,000 تومان
• فقط عدد بنویسید (مثال: 50000)

📤 <b>منتظر مبلغ شما هستیم...</b>`;

  // ذخیره حالت انتظار مبلغ
  await kv.put(`waiting_charge_amount_${chatId}`, JSON.stringify({
    chatId: chatId,
    messageId: messageId,
    timestamp: Date.now()
  }));

  await editMessage(chatId, messageId, chargeText, KEYBOARDS.backToWallet);
}

// پردازش مبلغ شارژ
async function processChargeAmount(chatId, messageText, kv) {
  const waitingData = await kv.get(`waiting_charge_amount_${chatId}`, 'json');
  
  if (!waitingData) {
    return; // عدم وجود درخواست شارژ
  }

  const amount = parseInt(messageText.replace(/[,\s]/g, ''));
  
  if (isNaN(amount)) {
    await sendMessage(chatId, '❌ لطفاً فقط عدد وارد کنید!\n\nمثال: 50000');
    return;
  }

  if (amount < 10000) {
    await sendMessage(chatId, '❌ حداقل مبلغ شارژ 10,000 تومان است!');
    return;
  }

  if (amount > 5000000) {
    await sendMessage(chatId, '❌ حداکثر مبلغ شارژ 5,000,000 تومان است!');
    return;
  }

  // ایجاد درخواست شارژ
  const chargeId = generateChargeId();
  const chargeData = {
    id: chargeId,
    chatId: chatId,
    amount: amount,
    status: 'waiting_payment',
    createdAt: Date.now(),
    expiresAt: Date.now() + (30 * 60 * 1000) // 30 دقیقه
  };

  await kv.put(`wallet_charge_${chargeId}`, JSON.stringify(chargeData));
  await kv.put(`user_charge_${chatId}`, chargeId);
  await kv.delete(`waiting_charge_amount_${chatId}`);

  const paymentText = `💳 <b>شارژ کیف پول</b>

💰 مبلغ شارژ: ${formatPrice(amount)}
🆔 کد شارژ: <code>${chargeId}</code>

💳 <b>اطلاعات واریز:</b>
🏦 کارت: <code>${PAYMENT_INFO.cardNumber}</code>
👤 نام: ${PAYMENT_INFO.cardHolder}

📋 <b>مراحل:</b>
1️⃣ مبلغ را واریز کنید
2️⃣ "پرداخت کردم" بزنید  
3️⃣ عکس رسید ارسال کنید
4️⃣ تا 30 دقیقه منتظر باشید

⚠️ درخواست 30 دقیقه اعتبار دارد`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '✅ پرداخت کردم', callback_data: 'upload_charge_receipt' }],
        [{ text: '❌ انصراف', callback_data: 'cancel_charge' }]
      ]
    }
  };

  await sendMessage(chatId, paymentText, keyboard);
}

// آپلود رسید شارژ
async function handleUploadChargeReceipt(chatId, messageId, kv) {
  const userCharge = await kv.get(`user_charge_${chatId}`);
  
  if (!userCharge) {
    await editMessage(chatId, messageId, '❌ درخواست شارژ فعالی یافت نشد!', KEYBOARDS.backToWallet);
    return;
  }

  const chargeData = await kv.get(`wallet_charge_${userCharge}`, 'json');
  if (!chargeData || chargeData.expiresAt < Date.now()) {
    await kv.delete(`user_charge_${chatId}`);
    await editMessage(chatId, messageId, 
      '❌ درخواست شارژ منقضی شده!\n\nلطفاً مجدداً درخواست دهید.',
      KEYBOARDS.backToWallet
    );
    return;
  }

  const uploadText = `📄 <b>ارسال رسید شارژ</b>

🆔 شارژ: <code>${userCharge}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

📱 <b>نحوه ارسال:</b>
• عکس رسید بانکی بفرستید
• یا فایل PDF ارسال کنید
• رسید باید واضح باشد

⏱️ بررسی: حداکثر 30 دقیقه
📤 <b>منتظر رسید شما هستیم...</b>`;

  await editMessage(chatId, messageId, uploadText, KEYBOARDS.backToWallet);
}

// پردازش آپلود رسید شارژ
async function processChargeReceiptUpload(chatId, messageData, kv) {
  const userCharge = await kv.get(`user_charge_${chatId}`);
  
  if (!userCharge) {
    await sendMessage(chatId, 
      '❌ درخواست شارژ فعالی یافت نشد!\n\nابتدا درخواست شارژ کنید.',
      KEYBOARDS.backToWallet
    );
    return;
  }

  const chargeData = await kv.get(`wallet_charge_${userCharge}`, 'json');
  
  if (!chargeData) {
    await sendMessage(chatId, '❌ اطلاعات شارژ یافت نشد!', KEYBOARDS.backToWallet);
    return;
  }

  if (chargeData.expiresAt < Date.now()) {
    await kv.delete(`user_charge_${chatId}`);
    await sendMessage(chatId, 
      '❌ درخواست شارژ منقضی شده!\n\nلطفاً مجدداً درخواست دهید.',
      KEYBOARDS.backToWallet
    );
    return;
  }

  chargeData.status = 'payment_submitted';
  chargeData.paymentSubmittedAt = Date.now();
  chargeData.receiptData = messageData;
  await kv.put(`wallet_charge_${userCharge}`, JSON.stringify(chargeData));

  await notifyAdminNewChargePayment(chargeData, messageData);

  const confirmText = `✅ <b>رسید شارژ دریافت شد!</b>

🆔 شارژ: <code>${userCharge}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

🔍 رسید برای مدیر ارسال شد
⏱️ زمان بررسی: حداکثر 30 دقیقه

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

  await sendMessage(chatId, confirmText, KEYBOARDS.backToWallet);
}

// نمایش حساب کاربری
// نمایش حساب کاربری - نسخه بهینه شده
async function showUserAccount(chatId, messageId, kv) {
  try {
    // نمایش loading
    await editMessage(chatId, messageId, '⏳ در حال بارگیری اطلاعات...', {});

    const balance = await getWalletBalance(chatId, kv);
    
    // جمع‌آوری داده‌ها به صورت موازی
    const [servicesResult, ordersResult, ticketsResult] = await Promise.all([
      kv.list(`service_${chatId}_`),
      kv.list('order_ORD_'),
      kv.list(`ticket_${chatId}_`)
    ]);
    
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    
    // آمار سرویس‌ها
    let activeServices = 0;
    let expiredServices = 0;
    let nearExpiry = 0;
    
    // فقط سرویس‌های کاربر را بررسی کن
    const servicePromises = servicesResult.keys.slice(0, 20).map(async (key) => {
      try {
        const service = await kv.get(key.name, 'json');
        if (service) {
          if (service.expireTimestamp > now) {
            activeServices++;
            const daysLeft = Math.ceil((service.expireTimestamp - now) / oneDayMs);
            if (daysLeft <= 7) nearExpiry++;
          } else {
            expiredServices++;
          }
        }
      } catch (e) {
        console.error('Error processing service:', e);
      }
    });
    
    await Promise.allSettled(servicePromises);
    
    // آمار سفارش‌ها - فقط 50 تای آخر
    let totalOrders = 0;
    let completedOrders = 0;
    let totalSpent = 0;
    
    const orderPromises = ordersResult.keys.slice(0, 50).map(async (key) => {
      try {
        const order = await kv.get(key.name, 'json');
        if (order && order.chatId === chatId) {
          totalOrders++;
          if (order.status === 'completed') {
            completedOrders++;
            totalSpent += order.plan.price;
          }
        }
      } catch (e) {
        console.error('Error processing order:', e);
      }
    });
    
    await Promise.allSettled(orderPromises);
    
    // آمار تیکت‌ها
    let totalTickets = 0;
    let openTickets = 0;
    
    const ticketPromises = ticketsResult.keys.map(async (key) => {
      try {
        const ticket = await kv.get(key.name, 'json');
        if (ticket) {
          totalTickets++;
          if (ticket.status === 'open') openTickets++;
        }
      } catch (e) {
        console.error('Error processing ticket:', e);
      }
    });
    
    await Promise.allSettled(ticketPromises);
    
    const accountText = `👤 <b>حساب کاربری</b>

🆔 <b>شناسه کاربری:</b> <code>${chatId}</code>

💰 <b>موجودی کیف پول:</b> ${formatPrice(balance)}

📊 <b>خلاصه سرویس‌ها:</b>
• فعال: ${activeServices} عدد
• منقضی: ${expiredServices} عدد
• نزدیک به انقضا: ${nearExpiry} عدد

💰 <b>خلاصه مالی:</b>
• کل خرید: ${formatPrice(totalSpent)}
• سفارش‌های موفق: ${completedOrders} از ${totalOrders}

🎫 <b>پشتیبانی:</b>
• تیکت‌های باز: ${openTickets} عدد
• کل تیکت‌ها: ${totalTickets} عدد

📅 <b>عضویت:</b> فعال`;

    const accountKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '📱 سرویس‌ها', callback_data: 'my_services' },
            { text: '🛒 خرید جدید', callback_data: 'buy_service' }
          ],
          [
            { text: '💰 کیف پول', callback_data: 'wallet_menu' },
            { text: '🎫 پشتیبانی', callback_data: 'support_menu' }
          ],
          [
            { text: '🔙 منوی اصلی', callback_data: 'start' }
          ]
        ]
      }
    };

    await editMessage(chatId, messageId, accountText, accountKeyboard);

  } catch (error) {
    console.error('Error showing user account:', error);
    await editMessage(chatId, messageId, 
      '❌ خطا در نمایش حساب کاربری.\n\nدوباره تلاش کنید.', 
      KEYBOARDS.backToMain
    );
  }
}

// نمایش منوی پشتیبانی
async function showSupportMenu(chatId, messageId, kv) {
  const supportText = `🎫 <b>منوی پشتیبانی</b>

💬 <b>راه‌های ارتباط با پشتیبانی:</b>

📱 تلگرام: @${PAYMENT_INFO.supportUsername}

🔧 <b>خدمات پشتیبانی:</b>
• رفع مشکلات فنی
• راهنمایی نصب و اتصال
• پیگیری سفارش‌ها
• درخواست‌های ویژه

🎯 <b>انتخاب کنید:</b>`;

  await editMessage(chatId, messageId, supportText, KEYBOARDS.supportMenu);
}

// نمایش سوالات متداول
async function showFAQ(chatId, messageId) {
  const faqText = `❓ <b>سوالات متداول</b>

🔵 <b>آیا همیشه پشتیبانی دارم؟</b>
✅ بله، همیشه پشتیبانی دارید تا لحظه آخر. تیم پشتیبانی ما 24 ساعته آماده کمک به شماست.

🔵 <b>آی پی ثابت است؟</b>
✅ بله، هر سرویس دارای آی پی ثابت و اختصاصی است که تا پایان مدت اشتراک تغییر نمی‌کند.

🔵 <b>آیا واقعا فیلترشکن است؟</b>
✅ بله، سرویس ما کاملاً ضدفیلتر و برای دسترسی آزاد به اینترنت طراحی شده است.

🔵 <b>سرعت اتصال چطور است؟</b>
✅ سرعت بسیار بالا با کمترین تاخیر. سرورهای ما در بهترین مراکز داده جهان قرار دارند.

🔵 <b>روی چه دستگاه‌هایی کار می‌کند؟</b>
✅ اندروید، آیفون، ویندوز، مک و همه پلتفرم‌ها پشتیبانی می‌شود.

🔵 <b>محدودیت کاربر همزمان دارد؟</b>
✅ هر اشتراک روی بیش از 2 تا 10 دستگاه همزمان قابل استفاده است.

🔵 <b>در صورت قطعی چه کنم؟</b>
✅ سرویس ما 99.9% آپتایم دارد. در موارد نادر، فوراً با پشتیبانی تماس بگیرید.

🔵 <b>آیا لاگ نگهداری می‌شود؟</b>
✅ خیر، هیچ لاگ و ردی از فعالیت شما نگهداری نمی‌شود. حریم خصوصی شما محفوظ است.

💬 <b>سوال دیگری دارید؟</b>
با پشتیبانی در ارتباط باشید: @${PAYMENT_INFO.supportUsername}`;

  const faqKeyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: '🎫 ثبت تیکت', callback_data: 'create_ticket' },
          { text: '💬 پشتیبانی مستقیم', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }
        ],
        [
          { text: '🔙 منوی پشتیبانی', callback_data: 'support_menu' }
        ]
      ]
    }
  };

  await editMessage(chatId, messageId, faqText, faqKeyboard);
}

// نمایش پلن‌های خرید
async function showBuyService(chatId, messageId, kv) {
  const plans = await getPlans(kv);
  
  let plansText = `🛒 <b>پلن‌های موجود</b>

✨ <b>سرویس‌های عالی و پایدار</b>
🌐 <b>عملکرد بهینه در شرایط اینترنت ملی</b>
👥 <b>بدون محدودیت تعداد کاربر</b>
🔒 <b>امنیت و پایداری بالا</b>

💎 <b>پلن مورد نظر خود را انتخاب کنید:</b>

`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: []
    }
  };

  // 👇 این خط رو تغییر بده 👇
  getSortedPlans(plans).forEach((plan) => {
    keyboard.reply_markup.inline_keyboard.push([{
      text: `${plan.name}`,
      callback_data: `select_plan_${plan.id}`
    }]);
  });
  
  keyboard.reply_markup.inline_keyboard.push([{
    text: '🔙 منوی اصلی',
    callback_data: 'start'
  }]);

  await editMessage(chatId, messageId, plansText, keyboard);
}

// نمایش جزئیات پلن انتخابی
async function showPlanDetails(chatId, messageId, planId, kv) {
  const plans = await getPlans(kv);
  const plan = plans[planId];
  
  if (!plan) {
    await editMessage(chatId, messageId, '❌ پلن یافت نشد!', KEYBOARDS.backToMain);
    return;
  }

  const defaultServer = await getDefaultServer(kv);
  
  await kv.put(`selected_plan_${chatId}`, JSON.stringify({
    planId: planId,
    plan: plan,
    serverId: defaultServer.id,
    serverName: defaultServer.name,
    selectedAt: Date.now(),
    expiresAt: Date.now() + (30 * 60 * 1000)
  }));

  const detailsText = `📦 <b>${plan.name}</b>

💰 قیمت: ${formatPrice(plan.price)}
📊 حجم: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}
⏰ مدت: ${plan.duration} روز
🖥️ سرور: ${defaultServer.name}

💡 ${plan.description}`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '💳 ادامه خرید', callback_data: 'proceed_payment' }],
        [{ text: '🔙 پلن‌های دیگر', callback_data: 'buy_service' }],
        [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
      ]
    }
  };

  await editMessage(chatId, messageId, detailsText, keyboard);
}

// انتخاب روش پرداخت
async function showPaymentMethod(chatId, messageId, kv) {
  const selectedPlanData = await kv.get(`selected_plan_${chatId}`, 'json');
  
  if (!selectedPlanData || !selectedPlanData.expiresAt || selectedPlanData.expiresAt < Date.now()) {
    await editMessage(chatId, messageId, 
      '❌ پلن انتخابی منقضی شده!\n\nلطفاً مجدداً انتخاب کنید.', 
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🛒 انتخاب پلن', callback_data: 'buy_service' }],
            [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
          ]
        }
      }
    );
    return;
  }

  const balance = await getWalletBalance(chatId, kv);
  const planPrice = selectedPlanData.plan.price;

  const paymentText = `💳 <b>انتخاب روش پرداخت</b>

📦 پلن: ${selectedPlanData.plan.name}
💰 مبلغ: ${formatPrice(planPrice)}

💰 موجودی کیف پول: ${formatPrice(balance)}

🎯 <b>روش پرداخت را انتخاب کنید:</b>`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: []
    }
  };

  // اگر موجودی کافی دارد، گزینه کیف پول را اضافه کن
  if (balance >= planPrice) {
    keyboard.reply_markup.inline_keyboard.push([{
      text: '💰 پرداخت با کیف پول',
      callback_data: 'pay_with_wallet'
    }]);
  }

  keyboard.reply_markup.inline_keyboard.push([{
    text: '💳 کارت به کارت',
    callback_data: 'pay_with_card'
  }]);

  keyboard.reply_markup.inline_keyboard.push([{
    text: '🔙 بازگشت',
    callback_data: `select_plan_${selectedPlanData.planId}`
  }]);

  await editMessage(chatId, messageId, paymentText, keyboard);
}

// پرداخت با کیف پول
async function payWithWallet(chatId, messageId, kv) {
  const selectedPlanData = await kv.get(`selected_plan_${chatId}`, 'json');
  
  if (!selectedPlanData || selectedPlanData.expiresAt < Date.now()) {
    await editMessage(chatId, messageId, '❌ پلن منقضی شده!', KEYBOARDS.backToMain);
    return;
  }

  const balance = await getWalletBalance(chatId, kv);
  const planPrice = selectedPlanData.plan.price;

  if (balance < planPrice) {
    await editMessage(chatId, messageId, 
      `❌ موجودی کافی نیست!\n\nموجودی فعلی: ${formatPrice(balance)}\nمبلغ مورد نیاز: ${formatPrice(planPrice)}`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '💳 شارژ کیف پول', callback_data: 'wallet_charge' }],
            [{ text: '💳 کارت به کارت', callback_data: 'pay_with_card' }],
            [{ text: '🔙 بازگشت', callback_data: 'proceed_payment' }]
          ]
        }
      }
    );
    return;
  }

  // ارسال پیام در حال ساخت
  const creatingMessage = await sendMessage(chatId, '⏳ <b>در حال ساخت سرویس...</b>\n\nلطفاً صبر کنید...');

  // کسر مبلغ از کیف پول
  const newBalance = await updateWalletBalance(chatId, -planPrice, kv);
  if (newBalance === false) {
    await deleteMessage(chatId, creatingMessage.result.message_id);
    await editMessage(chatId, messageId, '❌ خطا در کسر موجودی!', KEYBOARDS.backToMain);
    return;
  }

  // ثبت تراکنش
  await recordWalletTransaction(chatId, -planPrice, 'purchase', `خرید ${selectedPlanData.plan.name}`, kv);

  // ایجاد سفارش
  const orderId = generateOrderId();
  const orderData = {
    id: orderId,
    chatId: chatId,
    planId: selectedPlanData.planId,
    plan: selectedPlanData.plan,
    serverId: selectedPlanData.serverId,
    serverName: selectedPlanData.serverName,
    status: 'completed',
    paymentMethod: 'wallet',
    createdAt: Date.now(),
    completedAt: Date.now()
  };

  await kv.put(`order_${orderId}`, JSON.stringify(orderData));

  // ایجاد سرویس
  const serviceResult = await createServerService(orderData, kv);
  
  if (!serviceResult.success) {
    // بازگشت مبلغ در صورت خطا
    await updateWalletBalance(chatId, planPrice, kv);
    await recordWalletTransaction(chatId, planPrice, 'refund', `بازگشت وجه خرید ${selectedPlanData.plan.name}`, kv);
    
    await deleteMessage(chatId, creatingMessage.result.message_id);
    await editMessage(chatId, messageId, 
      `❌ خطا در ایجاد سرویس: ${serviceResult.error}\n\nمبلغ به کیف پول شما بازگردانده شد.`,
      KEYBOARDS.backToMain
    );
    return;
  }

  orderData.serviceData = serviceResult.serviceData;
  await kv.put(`order_${orderId}`, JSON.stringify(orderData));

  await kv.delete(`selected_plan_${chatId}`);

  // حذف پیام در حال ساخت
  await deleteMessage(chatId, creatingMessage.result.message_id);

  // ارسال کانفیگ جداگانه بدون دکمه
  await notifyUserServiceReady(orderData, serviceResult.serviceData);

  // پیام موفقیت با دکمه‌ها
  const successText = `✅ <b>سرویس با موفقیت ساخته شد!</b>

📦 پلن: ${selectedPlanData.plan.name}
👤 نام کاربری: <code>${serviceResult.serviceData.username}</code>
📅 تاریخ انقضا: ${formatDate(serviceResult.serviceData.expireTimestamp)}
⏰ زمان ساخت: ${formatDateTime(Date.now())}

💰 مبلغ پرداختی: ${formatPrice(planPrice)}
💳 روش پرداخت: کیف پول
💰 موجودی باقی‌مانده: ${formatPrice(newBalance)}

🎉 سرویس شما آماده استفاده است!`;

  await editMessage(chatId, messageId, successText, {
    reply_markup: {
      inline_keyboard: [
        [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }],
        [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
      ]
    }
  });
}

// مرحله پرداخت کارت به کارت
async function showCardPaymentStep(chatId, messageId, kv) {
  const selectedPlanData = await kv.get(`selected_plan_${chatId}`, 'json');
  
  if (!selectedPlanData || !selectedPlanData.expiresAt || selectedPlanData.expiresAt < Date.now()) {
    await editMessage(chatId, messageId, 
      '❌ پلن انتخابی منقضی شده!\n\nلطفاً مجدداً انتخاب کنید.', 
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🛒 انتخاب پلن', callback_data: 'buy_service' }],
            [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
          ]
        }
      }
    );
    return;
  }

  const orderId = generateOrderId();
  
  const orderData = {
    id: orderId,
    chatId: chatId,
    planId: selectedPlanData.planId,
    plan: selectedPlanData.plan,
    serverId: selectedPlanData.serverId,
    serverName: selectedPlanData.serverName,
    status: 'waiting_payment',
    paymentMethod: 'card',
    createdAt: Date.now(),
    expiresAt: Date.now() + (30 * 60 * 1000)
  };
  
  await kv.put(`order_${orderId}`, JSON.stringify(orderData));
  await kv.put(`user_order_${chatId}`, orderId);

  const paymentText = `💳 <b>پرداخت کارت به کارت</b>

📦 پلن: ${selectedPlanData.plan.name}
💰 مبلغ: ${formatPrice(selectedPlanData.plan.price)}
🆔 کد سفارش: <code>${orderId}</code>

💳 <b>اطلاعات واریز:</b>
🏦 کارت: <code>${PAYMENT_INFO.cardNumber}</code>
👤 نام: ${PAYMENT_INFO.cardHolder}

📋 <b>مراحل:</b>
1️⃣ مبلغ را واریز کنید
2️⃣ "پرداخت کردم" بزنید  
3️⃣ عکس رسید ارسال کنید
4️⃣ تا 30 دقیقه منتظر باشید

⚠️ سفارش 30 دقیقه اعتبار دارد`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '✅ پرداخت کردم', callback_data: 'upload_receipt' }],
        [{ text: '❌ انصراف', callback_data: 'cancel_order' }]
      ]
    }
  };

  await editMessage(chatId, messageId, paymentText, keyboard);
}

// آپلود رسید
async function handleUploadReceipt(chatId, messageId, kv) {
  const userOrder = await kv.get(`user_order_${chatId}`);
  
  if (!userOrder) {
    await editMessage(chatId, messageId, '❌ سفارش فعالی یافت نشد!', KEYBOARDS.backToMain);
    return;
  }

  const orderData = await kv.get(`order_${userOrder}`, 'json');
  if (!orderData || orderData.expiresAt < Date.now()) {
    await kv.delete(`user_order_${chatId}`);
    await editMessage(chatId, messageId, 
      '❌ سفارش منقضی شده!\n\nلطفاً مجدداً خرید کنید.',
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🛒 خرید مجدد', callback_data: 'buy_service' }],
            [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
          ]
        }
      }
    );
    return;
  }

  const uploadText = `📄 <b>ارسال رسید</b>

🆔 سفارش: <code>${userOrder}</code>

📱 <b>نحوه ارسال:</b>
• عکس رسید بانکی بفرستید
• یا فایل PDF ارسال کنید
• رسید باید واضح باشد

⏱️ بررسی: حداکثر 30 دقیقه
📤 <b>منتظر رسید شما هستیم...</b>`;

  await editMessage(chatId, messageId, uploadText, KEYBOARDS.backToMain);
}

// پردازش آپلود رسید
async function processReceiptUpload(chatId, messageData, kv) {
  const userOrder = await kv.get(`user_order_${chatId}`);
  
  if (!userOrder) {
    await sendMessage(chatId, 
      '❌ سفارش فعالی یافت نشد!\n\nابتدا یک پلن انتخاب کنید.',
      KEYBOARDS.backToMain
    );
    return;
  }

  const orderData = await kv.get(`order_${userOrder}`, 'json');
  
  if (!orderData) {
    await sendMessage(chatId, '❌ اطلاعات سفارش یافت نشد!', KEYBOARDS.backToMain);
    return;
  }

  if (orderData.expiresAt < Date.now()) {
    await kv.delete(`user_order_${chatId}`);
    await sendMessage(chatId, 
      '❌ سفارش منقضی شده!\n\nلطفاً مجدداً خرید کنید.',
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🛒 خرید مجدد', callback_data: 'buy_service' }],
            [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
          ]
        }
      }
    );
    return;
  }

  orderData.status = 'payment_submitted';
  orderData.paymentSubmittedAt = Date.now();
  orderData.receiptData = messageData;
  await kv.put(`order_${userOrder}`, JSON.stringify(orderData));

  await notifyAdminNewPayment(orderData, messageData);

  const confirmText = `✅ <b>رسید دریافت شد!</b>

🆔 سفارش: <code>${userOrder}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}

🔍 رسید برای مدیر ارسال شد
⏱️ زمان بررسی: حداکثر 30 دقیقه

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

  await sendMessage(chatId, confirmText, KEYBOARDS.backToMain);
}

// سرویس‌های کاربر - با صفحه‌بندی
async function showMyServices(chatId, messageId, kv, page = 1) {
  try {
    const userServicesResult = await kv.list(`service_${chatId}_`);
    const servicesPerPage = 10;
    
    let servicesText = `📱 <b>سرویس‌های من</b>\n\n`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    if (!userServicesResult.keys || userServicesResult.keys.length === 0) {
      servicesText += '❌ هیچ سرویس فعالی ندارید!';
    } else {
      // جمع‌آوری تمام سرویس‌ها
      const services = [];
      for (const key of userServicesResult.keys) {
        const serviceData = await kv.get(key.name, 'json');
        if (serviceData && serviceData.serviceId) {
          services.push(serviceData);
        }
      }

      if (services.length === 0) {
        servicesText += '❌ هیچ سرویس فعالی ندارید!';
      } else {
        // مرتب‌سازی بر اساس زمان خرید - جدیدترین اول
        services.sort((a, b) => {
          const timeA = a.createdAt || 0;
          const timeB = b.createdAt || 0;
          return timeB - timeA; // نزولی (جدید به قدیم)
        });

        // محاسبه صفحه‌بندی
        const totalServices = services.length;
        const totalPages = Math.ceil(totalServices / servicesPerPage);
        const startIndex = (page - 1) * servicesPerPage;
        const endIndex = Math.min(startIndex + servicesPerPage, totalServices);
        const currentPageServices = services.slice(startIndex, endIndex);

        // اضافه کردن اطلاعات صفحه‌بندی
        if (totalPages > 1) {
          servicesText += `📄 صفحه ${page} از ${totalPages} (${totalServices} سرویس)\n\n`;
        } else {
          servicesText += `📊 ${totalServices} سرویس\n\n`;
        }

        // اضافه کردن دکمه‌های سرویس‌های صفحه فعلی
        currentPageServices.forEach((serviceData, index) => {
          const serviceNumber = startIndex + index + 1;
          keyboard.reply_markup.inline_keyboard.push([{
            text: `${serviceNumber}. 📋 ${serviceData.username}`,
            callback_data: `manage_service_${serviceData.serviceId}`
          }]);
        });

        // اضافه کردن دکمه‌های ناوبری صفحه‌بندی
        if (totalPages > 1) {
          const navigationRow = [];
          
          // دکمه صفحه قبل
          if (page > 1) {
            navigationRow.push({
              text: '◀️ قبلی',
              callback_data: `services_page_${page - 1}`
            });
          }
          
          // نمایش شماره صفحه فعلی
          navigationRow.push({
            text: `${page}/${totalPages}`,
            callback_data: 'current_page'
          });
          
          // دکمه صفحه بعد
          if (page < totalPages) {
            navigationRow.push({
              text: 'بعدی ▶️',
              callback_data: `services_page_${page + 1}`
            });
          }
          
          keyboard.reply_markup.inline_keyboard.push(navigationRow);
        }
      }
    }

    // اضافه کردن گزینه‌های اصلی
    keyboard.reply_markup.inline_keyboard.push([{
      text: '🔍 سرویس من توی لیست نیست',
      callback_data: 'find_my_service'
    }]);

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🛒 خرید سرویس جدید',
      callback_data: 'buy_service'
    }]);

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🔙 منوی اصلی',
      callback_data: 'start'
    }]);

    await editMessage(chatId, messageId, servicesText, keyboard);

  } catch (error) {
    console.error('Error showing services:', error);
    await editMessage(chatId, messageId, 
      '❌ خطا در نمایش سرویس‌ها.',
      KEYBOARDS.backToMain
    );
  }
}

// پیدا کردن سرویس
async function showFindMyService(chatId, messageId, kv) {
  const findText = `🔍 <b>پیدا کردن سرویس</b>

📝 نام کاربری که موقع خرید به شما داده شده را وارد کنید:

💡 <b>راهنما:</b>
• نام کاربری معمولاً شامل حروف و اعداد است
• مثال: user_123456_789
• دقیقاً همان نامی که دریافت کرده‌اید

📤 <b>منتظر نام کاربری شما هستیم...</b>`;

  // ذخیره حالت انتظار نام کاربری
  await kv.put(`waiting_username_${chatId}`, JSON.stringify({
    chatId: chatId,
    messageId: messageId,
    timestamp: Date.now()
  }));

  await editMessage(chatId, messageId, findText, {
    reply_markup: {
      inline_keyboard: [
        [{ text: '🔙 سرویس‌های من', callback_data: 'my_services' }]
      ]
    }
  });
}

// پردازش نام کاربری جستجو
async function processUsernameSearch(chatId, messageText, kv) {
  const waitingData = await kv.get(`waiting_username_${chatId}`, 'json');
  
  if (!waitingData) {
    return; // عدم وجود درخواست جستجو
  }

  const username = messageText.trim();
  
  if (!username || username.length < 3) {
    await sendMessage(chatId, '❌ نام کاربری وارد شده نامعتبر است!\n\nلطفاً نام کاربری صحیح را وارد کنید.');
    return;
  }

  await kv.delete(`waiting_username_${chatId}`);

  // جستجو در سرویس‌های کاربر
  const serviceResult = await findServiceByUsername(chatId, username, kv);
  
  if (!serviceResult) {
    const notFoundText = `❌ <b>سرویس یافت نشد!</b>

👤 نام کاربری: <code>${username}</code>

🔍 <b>دلایل احتمالی:</b>
• نام کاربری اشتباه وارد شده
• سرویس متعلق به شما نیست
• سرویس حذف شده است

💬 در صورت اطمینان از صحت نام کاربری، با پشتیبانی تماس بگیرید: @${PAYMENT_INFO.supportUsername}`;

    await sendMessage(chatId, notFoundText, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔍 جستجوی مجدد', callback_data: 'find_my_service' }],
          [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }]
        ]
      }
    });
    return;
  }

  const serviceData = serviceResult.data;
  const remainingDays = Math.ceil((serviceData.expireTimestamp - Date.now()) / (1000 * 60 * 60 * 24));
  const isExpiring = remainingDays <= 3;
  const isExpired = remainingDays <= 0;

  const foundText = `✅ <b>سرویس پیدا شد!</b>

📋 <b>${serviceData.planName}</b>
👤 کاربری: <code>${serviceData.username}</code>
📊 حجم: ${serviceData.dataLimit ? serviceData.dataLimit + ' گیگ' : 'نامحدود'}
📅 انقضا: ${formatDate(serviceData.expireTimestamp)}
⏰ باقی‌مانده: ${remainingDays} روز ${isExpired ? '❌' : isExpiring ? '⚠️' : '✅'}
🖥️ سرور: ${serviceData.serverName || 'نامشخص'}
📊 وضعیت: ${serviceData.status === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}

🎯 <b>اکنون می‌توانید سرویس خود را مدیریت کنید:</b>`;

  await sendMessage(chatId, foundText, {
    reply_markup: {
      inline_keyboard: [
        [{ text: '📱 مدیریت سرویس', callback_data: `manage_service_${serviceData.serviceId}` }],
        [{ text: '🔍 جستجوی مجدد', callback_data: 'find_my_service' }],
        [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }]
      ]
    }
  });
}

// مدیریت سرویس - نسخه بهینه شده
// مدیریت سرویس - نسخه بهینه شده
async function showServiceManagement(chatId, messageId, serviceId, kv, sendConfig = false) {
  try {
    console.log('Managing service:', chatId, serviceId);
    
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;

    const remainingDays = Math.ceil((serviceData.expireTimestamp - Date.now()) / (1000 * 60 * 60 * 24));
    const isExpiring = remainingDays <= 3;
    const isExpired = remainingDays <= 0;
    
    // ابتدا جزئیات مدیریت را نمایش بده
    const managementText = `📱 <b>مدیریت سرویس</b>

📋 <b>${serviceData.planName}</b>
👤 نام کاربری: <code>${serviceData.username}</code>
📊 حجم: ${serviceData.dataLimit ? serviceData.dataLimit + ' گیگ' : 'نامحدود'}
📅 انقضا: ${formatDate(serviceData.expireTimestamp)}
⏰ باقی‌مانده: ${remainingDays} روز ${isExpired ? '❌' : isExpiring ? '⚠️' : '✅'}
🖥️ سرور: ${serviceData.serverName || 'نامشخص'}
📊 وضعیت: ${serviceData.status === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}

🔧 <b>گزینه‌های مدیریت:</b>`;

const managementKeyboard = {
  reply_markup: {
    inline_keyboard: [
      [
        { text: '🔄 تمدید سرویس', callback_data: `renew_service_${serviceId}` },
        { text: '⚡ وضعیت سرویس', callback_data: `service_status_${serviceId}` }
      ],
      [
        { text: '📊 مصرف ترافیک', callback_data: `traffic_usage_${serviceId}` },
        { text: serviceData.status === 'active' ? '⏸️ توقف سرویس' : '▶️ فعالسازی', 
          callback_data: `toggle_service_${serviceId}` }
      ],
      [
        { text: '🔗 دریافت کانفیگ', callback_data: `get_config_${serviceId}` },
        { text: '🔄 تغییر لینک', callback_data: `reset_link_${serviceId}` }
      ],
      [
        { text: '💎 پشتیبانی مستقیم', 
          url: `https://t.me/${PAYMENT_INFO.supportUsername}?start=service_${serviceId}` }
      ],
      [{ text: '🔙 سرویس‌های من', callback_data: 'my_services' }],
      [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
    ]
  }
};

    await editMessage(chatId, messageId, managementText, managementKeyboard);

    // فقط در صورت درخواست، QR کد و لینک را ارسال کن
    if (sendConfig && serviceData.configUrl) {
      const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=400x400&format=png&data=${encodeURIComponent(serviceData.configUrl)}`;
      
      const qrCaption = `🔗 <b>لینک اشتراک سرویس</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>

🔗 <b>لینک:</b>
<code>${serviceData.configUrl}</code>

💡 <b>نحوه استفاده:</b>
• QR کد را اسکن کنید یا لینک را کپی کنید
• در اپلیکیشن VPN وارد کنید

📱 <b>اپلیکیشن‌های پیشنهادی:</b>
🤖 اندروید: V2rayNG
🍎 آیفون: Fair VPN یا Shadowrocket
💻 ویندوز: V2rayN
🖥️ مک: ClashX
🏠 منوی اصلی: /start`;

      await sendPhoto(chatId, qrUrl, qrCaption);
    }

  } catch (error) {
    console.error('Error showing service management:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش سرویس.', KEYBOARDS.backToMain);
  }
}

async function showServiceRenewal(chatId, messageId, serviceId, kv) {
  try {
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;
    const plans = await getPlans(kv);
    const remainingDays = Math.ceil((serviceData.expireTimestamp - Date.now()) / (1000 * 60 * 60 * 24));
    
    let renewalText = `🔄 <b>تمدید سرویس</b>

📋 <b>سرویس فعلی:</b> ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📅 انقضا: ${formatDate(serviceData.expireTimestamp)}
⏰ باقی‌مانده: ${remainingDays} روز

⚠️ <b>هشدار مهم:</b>
پس از تمدید، زمان و حجم جدید به زمان و حجم قبلی اضافه می‌شود.
سرویس قبلی حذف نمی‌شود بلکه تمدید می‌یابد.

🔸 <b>گزینه‌های تمدید را انتخاب کنید:</b>`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    getSortedPlans(plans).forEach((plan) => {
      keyboard.reply_markup.inline_keyboard.push([{
        text: `🔄 ${plan.name}`,
        callback_data: `renew_with_plan|${serviceId}|${plan.id}`
      }]);
    });

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🔙 بازگشت به سرویس',
      callback_data: `manage_service_${serviceId}`
    }]);

    await editMessage(chatId, messageId, renewalText, keyboard);

  } catch (error) {
    console.error('Error showing service renewal:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش تمدید.', KEYBOARDS.backToMain);
  }
}

async function processRenewalWithPlan(chatId, messageId, serviceId, planId, kv) {
  try {
    const plans = await getPlans(kv);
    const plan = plans[planId];
    
    if (!plan) {
      await editMessage(chatId, messageId, '❌ یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceResult = await findServiceById(chatId, serviceId, kv);
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;
    const balance = await getWalletBalance(chatId, kv);

    // ذخیره اطلاعات تمدید
    await kv.put(`renewal_plan_${chatId}`, JSON.stringify({
      planId: planId,
      plan: plan,
      serviceId: serviceId,
      serviceData: serviceData,
      selectedAt: Date.now(),
      expiresAt: Date.now() + (30 * 60 * 1000)
    }));

    const renewalPaymentText = `💳 <b>تأیید تمدید سرویس</b>

📋 <b>سرویس فعلی:</b> ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>

🔄 <b>تمدید انتخابی:</b> ${plan.name}
💰 قیمت: ${formatPrice(plan.price)}
📊 حجم اضافی: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}
⏰ زمان اضافی: ${plan.duration} روز
💡 ${plan.description}

⚠️ <b>نکته:</b> 
• زمان: ${plan.duration} روز به انقضای فعلی اضافه می‌شود
• حجم: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'حجم نامحدود'} به حجم فعلی اضافه می‌شود

💰 موجودی کیف پول: ${formatPrice(balance)}

🎯 <b>روش پرداخت را انتخاب کنید:</b>`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    if (balance >= plan.price) {
      keyboard.reply_markup.inline_keyboard.push([{
        text: '💰 پرداخت با کیف پول',
        callback_data: `renew_wallet|${serviceId}|${planId}`
      }]);
    }

    keyboard.reply_markup.inline_keyboard.push([{
      text: '💳 کارت به کارت',
      callback_data: `renew_card|${serviceId}|${planId}`
    }]);

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🔙 بازگشت',
      callback_data: `renew_service_${serviceId}`
    }]);

    await editMessage(chatId, messageId, renewalPaymentText, keyboard);

  } catch (error) {
    console.error('Error processing renewal:', error);
    await editMessage(chatId, messageId, '❌ خطا در پردازش تمدید.', KEYBOARDS.backToMain);
  }
}

// تمدید با کیف پول - کد کامل و اصلاح‌شده با استفاده از جداکننده |
async function renewWithWallet(chatId, messageId, serviceId, planId, kv) {
  try {
    // بررسی اطلاعات ذخیره‌شده
    const renewalData = await kv.get(`renewal_plan_${chatId}`, 'json');
    
    if (!renewalData || renewalData.expiresAt < Date.now()) {
      await editMessage(chatId, messageId, 
        '❌ اطلاعات تمدید منقضی شده!\n\nلطفاً مجدداً انتخاب کنید.', {
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔄 تمدید سرویس', callback_data: `renew_service_${serviceId}` }],
              [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
            ]
          }
        }
      );
      return;
    }

    const plan = renewalData.plan;
    const serviceData = renewalData.serviceData;
    const balance = await getWalletBalance(chatId, kv);

    if (balance < plan.price) {
      await editMessage(chatId, messageId, 
        `❌ موجودی کافی نیست!\n\nموجودی فعلی: ${formatPrice(balance)}\nمبلغ مورد نیاز: ${formatPrice(plan.price)}`, {
          reply_markup: {
            inline_keyboard: [
              [{ text: '💳 شارژ کیف پول', callback_data: 'wallet_charge' }],
              [{ text: '💳 کارت به کارت', callback_data: `renew_card|${serviceId}|${planId}` }],
              [{ text: '🔙 بازگشت', callback_data: `renew_with_plan|${serviceId}|${planId}` }]
            ]
          }
        }
      );
      return;
    }

    // ارسال پیام در حال تمدید
    const renewingMessage = await sendMessage(chatId, '⏳ <b>در حال تمدید سرویس...</b>\n\nلطفاً صبر کنید...');

    // کسر مبلغ از کیف پول
    const newBalance = await updateWalletBalance(chatId, -plan.price, kv);
    if (newBalance === false) {
      await deleteMessage(chatId, renewingMessage.result.message_id);
      await editMessage(chatId, messageId, '❌ خطا در کسر موجودی!', KEYBOARDS.backToMain);
      return;
    }

    // ثبت تراکنش
    await recordWalletTransaction(chatId, -plan.price, 'purchase', `تمدید ${serviceData.planName} با ${plan.name}`, kv);

    // ایجاد سفارش تمدید
    const orderId = generateOrderId();
    const orderData = {
      id: orderId,
      chatId: chatId,
      planId: renewalData.planId,
      plan: plan,
      serviceId: serviceId,
      serviceData: serviceData,
      type: 'renewal',
      status: 'completed',
      paymentMethod: 'wallet',
      createdAt: Date.now(),
      completedAt: Date.now()
    };

    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    // تمدید سرویس در سرور
    const renewalResult = await renewExistingService(orderData, kv);
    
    if (!renewalResult.success) {
      // بازگشت مبلغ در صورت خطا
      await updateWalletBalance(chatId, plan.price, kv);
      await recordWalletTransaction(chatId, plan.price, 'refund', `بازگشت وجه تمدید ${serviceData.planName}`, kv);
      
      await deleteMessage(chatId, renewingMessage.result.message_id);
      await editMessage(chatId, messageId, 
        `❌ خطا در تمدید سرویس: ${renewalResult.error}\n\nمبلغ به کیف پول شما بازگردانده شد.`,
        KEYBOARDS.backToMain
      );
      return;
    }

    // بروزرسانی داده‌های سفارش با اطلاعات جدید سرویس
    orderData.serviceData = renewalResult.serviceData;
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    // پاک کردن داده‌های موقت تمدید
    await kv.delete(`renewal_plan_${chatId}`);

    // حذف پیام "در حال تمدید"
    await deleteMessage(chatId, renewingMessage.result.message_id);

    // ارسال موفقیت به کاربر
    // پیام موفقیت با دکمه‌ها
// پیام موفقیت با دکمه‌ها
const successText = `✅ <b>سرویس با موفقیت تمدید شد!</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
🔄 تمدید: ${plan.name}
⏰ زمان اضافه شده: ${plan.duration} روز
📊 حجم اضافه شده: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}
📅 انقضای جدید: ${formatDate(renewalResult.serviceData.expireTimestamp)}

💰 مبلغ پرداختی: ${formatPrice(plan.price)}
💳 روش پرداخت: کیف پول
💰 موجودی باقی‌مانده: ${formatPrice(newBalance)}

🎉 سرویس شما تمدید شد!`;

    await editMessage(chatId, messageId, successText, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }],
          [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
        ]
      }
    });

  } catch (error) {
    console.error('Error renewing with wallet:', error);
    await editMessage(chatId, messageId, '❌ خطا در تمدید سرویس.', KEYBOARDS.backToMain);
  }
}

// تمدید با کارت به کارت
async function renewWithCard(chatId, messageId, serviceId, planId, kv) {
  try {
    // استفاده از اطلاعات ذخیره شده
    const renewalData = await kv.get(`renewal_plan_${chatId}`, 'json');
    
    if (!renewalData || renewalData.expiresAt < Date.now()) {
      await editMessage(chatId, messageId, 
        '❌ اطلاعات تمدید منقضی شده!\n\nلطفاً مجدداً انتخاب کنید.',
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔄 تمدید سرویس', callback_data: `renew_service_${serviceId}` }],
              [{ text: '🔙 منوی اصلی', callback_data: 'start' }]
            ]
          }
        }
      );
      return;
    }

    const plan = renewalData.plan;
    const serviceData = renewalData.serviceData;

    // ایجاد سفارش تمدید
    const orderId = generateOrderId();
    const orderData = {
      id: orderId,
      chatId: chatId,
      planId: renewalData.planId,
      plan: plan,
      serviceId: serviceId,
      serviceData: serviceData,
      type: 'renewal',
      status: 'waiting_payment',
      paymentMethod: 'card',
      createdAt: Date.now(),
      expiresAt: Date.now() + (30 * 60 * 1000)
    };
    
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));
    await kv.put(`user_order_${chatId}`, orderId);

    const paymentText = `💳 <b>پرداخت تمدید</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
🔄 پلن تمدید: ${plan.name}
💰 مبلغ: ${formatPrice(plan.price)}
🆔 کد سفارش: <code>${orderId}</code>

💳 <b>اطلاعات واریز:</b>
🏦 کارت: <code>${PAYMENT_INFO.cardNumber}</code>
👤 نام: ${PAYMENT_INFO.cardHolder}

📋 <b>مراحل:</b>
1️⃣ مبلغ را واریز کنید
2️⃣ "پرداخت کردم" بزنید  
3️⃣ عکس رسید ارسال کنید
4️⃣ تا 30 دقیقه منتظر باشید

⚠️ سفارش 30 دقیقه اعتبار دارد`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '✅ پرداخت کردم', callback_data: 'upload_receipt' }],
          [{ text: '❌ انصراف', callback_data: 'cancel_order' }]
        ]
      }
    };

    await editMessage(chatId, messageId, paymentText, keyboard);

  } catch (error) {
    console.error('Error processing card renewal:', error);
    await editMessage(chatId, messageId, '❌ خطا در پردازش تمدید.', KEYBOARDS.backToMain);
  }
}

// وضعیت سرویس و ترافیک
async function showServiceStatus(chatId, messageId, serviceId, kv) {
  try {
    console.log('Showing status for service:', chatId, serviceId);
    
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;

    // اتصال به سرور برای دریافت اطلاعات آپدیت
    const servers = await getServers(kv);
    const server = servers[serviceData.serverId];
    
    let statusText = `⚡ <b>وضعیت سرویس</b>

📋 نام: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📊 وضعیت: ${serviceData.status === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}
🖥️ سرور: ${serviceData.serverName}

`;

    if (server) {
      try {
        const api = new MarzbanAPI(server.baseUrl);
        const loginResult = await api.login(server.username, server.password);
        
        if (loginResult.success) {
          const userResult = await api.getUser(serviceData.username);
          
          if (userResult.success) {
            const userData = userResult.data;
            const usedTraffic = userData.used_traffic || 0;
            const totalTraffic = userData.data_limit || 0;
            
            statusText += `📈 <b>مصرف ترافیک:</b>
📊 مصرف شده: ${formatBytes(usedTraffic)}
📋 کل حجم: ${totalTraffic ? formatBytes(totalTraffic) : 'نامحدود'}
💯 درصد مصرف: ${totalTraffic ? ((usedTraffic / totalTraffic) * 100).toFixed(1) + '%' : '0%'}

📅 <b>زمان:</b>
🕐 آخرین اتصال: ${userData.last_connected ? formatDateTime(new Date(userData.last_connected).getTime()) : 'هیچ‌وقت'}
⏰ انقضا: ${formatDate(serviceData.expireTimestamp)}

🔗 <b>اتصالات فعال:</b> ${userData.connections?.length || 0}`;
          } else {
            statusText += '❌ خطا در دریافت اطلاعات از سرور';
          }
        } else {
          statusText += '❌ خطا در اتصال به سرور';
        }
      } catch (error) {
        statusText += '❌ خطا در ارتباط با سرور';
      }
    } else {
      statusText += '❌ سرور یافت نشد';
    }

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔄 بروزرسانی', callback_data: `service_status_${serviceId}` }],
          [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }]
        ]
      }
    };

    await editMessage(chatId, messageId, statusText, keyboard);

  } catch (error) {
    console.error('Error showing service status:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش وضعیت.', KEYBOARDS.backToMain);
  }
}

// تغییر وضعیت سرویس (فعال/غیرفعال)
async function toggleServiceStatus(chatId, messageId, serviceId, kv) {
  try {
    console.log('Toggling service status:', chatId, serviceId);
    
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;
    const servers = await getServers(kv);
    const server = servers[serviceData.serverId];
    
    if (!server) {
      await editMessage(chatId, messageId, '❌ سرور یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    try {
      const api = new MarzbanAPI(server.baseUrl);
      const loginResult = await api.login(server.username, server.password);
      
      if (!loginResult.success) {
        await editMessage(chatId, messageId, '❌ خطا در اتصال به سرور!', KEYBOARDS.backToMain);
        return;
      }

      const newStatus = serviceData.status === 'active' ? 'disabled' : 'active';
      
      const updateResult = await api.modifyUser(serviceData.username, {
        status: newStatus
      });

      if (updateResult.success) {
        serviceData.status = newStatus;
        await kv.put(serviceResult.key, JSON.stringify(serviceData));
        
        // پیام موفقیت
        const successText = `✅ وضعیت سرویس تغییر کرد!

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
📊 وضعیت جدید: ${newStatus === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}`;

        const keyboard = {
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }]
            ]
          }
        };

        await editMessage(chatId, messageId, successText, keyboard);
        
      } else {
        await editMessage(chatId, messageId, 
          `❌ خطا در تغییر وضعیت: ${updateResult.error}`,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }]
              ]
            }
          }
        );
      }

    } catch (error) {
      await editMessage(chatId, messageId, '❌ خطا در ارتباط با سرور!', KEYBOARDS.backToMain);
    }

  } catch (error) {
    console.error('Error toggling service status:', error);
    await editMessage(chatId, messageId, '❌ خطا در تغییر وضعیت.', KEYBOARDS.backToMain);
  }
}

// نمایش تأیید تغییر لینک
async function showResetLinkConfirmation(chatId, messageId, serviceId, kv) {
  try {
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;

    const confirmText = `⚠️ <b>تأیید تغییر لینک سرویس</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>

🚨 <b>هشدار مهم:</b>
• لینک اشتراک کاملاً تغییر خواهد کرد
• همه دستگاه‌های متصل قطع می‌شوند
• باید لینک جدید را در همه دستگاه‌ها وارد کنید
• این عمل قابل بازگشت نیست

❓ <b>آیا مطمئن هستید؟</b>`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '✅ بله، تغییر بده', callback_data: `confirm_reset_${serviceId}` }
          ],
          [
            { text: '❌ انصراف', callback_data: `manage_service_${serviceId}` }
          ]
        ]
      }
    };

    await editMessage(chatId, messageId, confirmText, keyboard);

  } catch (error) {
    console.error('Error showing reset confirmation:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش تأیید.', KEYBOARDS.backToMain);
  }
}

// پردازش تغییر لینک
async function processResetLink(chatId, messageId, serviceId, kv) {
  try {
    const serviceResult = await findServiceById(chatId, serviceId, kv);
    
    if (!serviceResult) {
      await editMessage(chatId, messageId, '❌ سرویس یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    const serviceData = serviceResult.data;
    const servers = await getServers(kv);
    const server = servers[serviceData.serverId];
    
    if (!server) {
      await editMessage(chatId, messageId, '❌ سرور یافت نشد!', KEYBOARDS.backToMain);
      return;
    }

    // نمایش پیام در حال پردازش
    await editMessage(chatId, messageId, '⏳ <b>در حال تغییر لینک...</b>\n\nلطفاً صبر کنید...', {});

    try {
      const api = new MarzbanAPI(server.baseUrl);
      const loginResult = await api.login(server.username, server.password);
      
      if (!loginResult.success) {
        await editMessage(chatId, messageId, '❌ خطا در اتصال به سرور!', KEYBOARDS.backToMain);
        return;
      }

      // ریست کردن secret کاربر برای تغییر لینک
      const resetResult = await api.request(`${api.apiPath}/user/${encodeURIComponent(serviceData.username)}/reset`, {
        method: 'POST'
      });

      if (!resetResult.success) {
        await editMessage(chatId, messageId, 
          `❌ خطا در تغییر لینک: ${resetResult.error}`,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }]
              ]
            }
          }
        );
        return;
      }

      // کمی صبر کنیم تا لینک جدید آماده شود
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // دریافت لینک جدید
      const userResult = await api.getUser(serviceData.username);
      let newConfigUrl = null;
      
      if (userResult.success && userResult.data.subscription_url) {
        newConfigUrl = userResult.data.subscription_url.startsWith('http') ? 
                      userResult.data.subscription_url : 
                      `${api.baseUrl}${userResult.data.subscription_url}`;
      }

      if (newConfigUrl) {
        // بروزرسانی لینک در دیتابیس
        serviceData.configUrl = newConfigUrl;
        serviceData.linkResetAt = Date.now();
        await kv.put(serviceResult.key, JSON.stringify(serviceData));

        // ارسال لینک جدید جداگانه
        const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=400x400&format=png&data=${encodeURIComponent(newConfigUrl)}`;
        
        const configText = `🔗 <b>لینک جدید سرویس</b>

👤 کاربری: <code>${serviceData.username}</code>

🔗 <b>لینک جدید:</b>
<code>${newConfigUrl}</code>

💡 <b>نکته مهم:</b>
• لینک قبلی دیگر کار نمی‌کند
• این لینک را در همه دستگاه‌ها وارد کنید
• همه دستگاه‌های قبلی قطع شده‌اند

📱 <b>نحوه استفاده:</b>
• QR کد را اسکن کنید یا لینک را کپی کنید
• در اپلیکیشن VPN وارد کنید`;

        await sendPhoto(chatId, qrUrl, configText);

        // پیام موفقیت
        const successText = `✅ <b>لینک سرویس تغییر کرد!</b>

📋 سرویس: ${serviceData.planName}
👤 کاربری: <code>${serviceData.username}</code>
🕐 زمان تغییر: ${formatDateTime(Date.now())}

🎉 لینک جدید برای شما ارسال شد!

⚠️ <b>یادآوری:</b>
• لینک قبلی دیگر کار نمی‌کند
• همه دستگاه‌های قبلی قطع شده‌اند
• لینک جدید را در همه دستگاه‌ها تنظیم کنید`;

        const keyboard = {
          reply_markup: {
            inline_keyboard: [
              [{ text: '📱 مدیریت سرویس', callback_data: `manage_service_${serviceId}` }],
              [{ text: '🔗 دریافت مجدد لینک', callback_data: `get_config_${serviceId}` }],
              [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
            ]
          }
        };

        await editMessage(chatId, messageId, successText, keyboard);

      } else {
        await editMessage(chatId, messageId, 
          '❌ خطا در دریافت لینک جدید!\n\nلطفاً با پشتیبانی تماس بگیرید.',
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }],
                [{ text: '💬 پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
              ]
            }
          }
        );
      }

    } catch (error) {
      await editMessage(chatId, messageId, 
        '❌ خطا در ارتباط با سرور!\n\nلطفاً دوباره تلاش کنید.',
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔄 تلاش مجدد', callback_data: `reset_link_${serviceId}` }],
              [{ text: '🔙 بازگشت به سرویس', callback_data: `manage_service_${serviceId}` }]
            ]
          }
        }
      );
    }

  } catch (error) {
    console.error('Error processing reset link:', error);
    await editMessage(chatId, messageId, '❌ خطا در تغییر لینک.', KEYBOARDS.backToMain);
  }
}

// نمایش راهنمای اتصال
async function showConnectionGuide(chatId, messageId) {
  const guideText = `📖 <b>راهنمای اتصال</b>

📱 <b>اندروید:</b>
• V2rayNG را نصب کنید
• روی + بزنید و Subscription انتخاب کنید
• لینک اشتراک را وارد کنید

🍎 <b>آیفون:</b>
• Fair VPN یا Shadowrocket نصب کنید  
• لینک اشتراک را اضافه کنید

💻 <b>ویندوز:</b>
• V2rayN دانلود کنید
• Subscription → Add را بزنید
• لینک را وارد کنید

🖥️ <b>مک:</b>
• ClashX نصب کنید
• Config → Remote Config → Manage
• لینک را اضافه کنید

💡 <b>نکته:</b> بعد از خرید، لینک اشتراک برای شما ارسال می‌شود.

💬 <b>پشتیبانی:</b> @${PAYMENT_INFO.supportUsername}`;

  await editMessage(chatId, messageId, guideText, KEYBOARDS.backToMain);
}

// ثبت تیکت جدید
async function showCreateTicket(chatId, messageId, kv) {
  // بررسی تیکت باز
  const openTickets = await kv.list(`ticket_${chatId}_`);
  let hasOpenTicket = false;
  
  for (const key of openTickets.keys) {
    const ticket = await kv.get(key.name, 'json');
    if (ticket && ticket.status === 'open') {
      hasOpenTicket = true;
      break;
    }
  }

  if (hasOpenTicket) {
    await editMessage(chatId, messageId, 
      '⚠️ شما یک تیکت باز دارید!\n\nابتدا تیکت قبلی را ببندید.', 
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🎫 مشاهده تیکت‌ها', callback_data: 'my_tickets' }],
            [{ text: '🔙 منوی پشتیبانی', callback_data: 'support_menu' }]
          ]
        }
      }
    );
    return;
  }

  const createText = `🎫 <b>ثبت تیکت پشتیبانی</b>

📝 موضوع تیکت را انتخاب کنید:`;

  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '❓ سوال فنی', callback_data: 'ticket_type_technical' }],
        [{ text: '💰 مشکل پرداخت', callback_data: 'ticket_type_payment' }],
        [{ text: '🔧 مشکل اتصال', callback_data: 'ticket_type_connection' }],
        [{ text: '📋 درخواست ویژه', callback_data: 'ticket_type_request' }],
        [{ text: '🔙 منوی پشتیبانی', callback_data: 'support_menu' }]
      ]
    }
  };

  await editMessage(chatId, messageId, createText, keyboard);
}

// انتخاب نوع تیکت
async function selectTicketType(chatId, messageId, ticketType, kv) {
  const typeNames = {
    'technical': 'سوال فنی',
    'payment': 'مشکل پرداخت', 
    'connection': 'مشکل اتصال',
    'request': 'درخواست ویژه'
  };

  // ذخیره نوع تیکت
  await kv.put(`pending_ticket_${chatId}`, JSON.stringify({
    type: ticketType,
    typeName: typeNames[ticketType],
    chatId: chatId,
    createdAt: Date.now()
  }));

  const waitText = `📝 <b>ثبت تیکت: ${typeNames[ticketType]}</b>

لطفاً پیام خود را بنویسید:

💡 <b>نکات:</b>
• واضح و مفصل بنویسید
• اگر مشکل فنی دارید، جزئیات بدهید
• تا 500 کاراکتر

📤 <b>منتظر پیام شما هستیم...</b>`;

  await editMessage(chatId, messageId, waitText, KEYBOARDS.backToSupport);
}

// پردازش پیام تیکت
async function processTicketMessage(chatId, messageText, kv) {
  const pendingTicket = await kv.get(`pending_ticket_${chatId}`, 'json');
  
  if (!pendingTicket) {
    await sendMessage(chatId, '❌ تیکت در حال انتظاری یافت نشد!', KEYBOARDS.backToSupport);
    return;
  }

  if (messageText.length > 500) {
    await sendMessage(chatId, '❌ پیام شما بیش از 500 کاراکتر است!\n\nلطفاً کوتاه‌تر بنویسید.');
    return;
  }

  const ticketId = generateTicketId();
  const ticketData = {
    id: ticketId,
    chatId: chatId,
    type: pendingTicket.type,
    typeName: pendingTicket.typeName,
    subject: messageText.substring(0, 50) + (messageText.length > 50 ? '...' : ''),
    message: messageText,
    status: 'open',
    createdAt: Date.now(),
    messages: [
      {
        from: 'user',
        message: messageText,
        timestamp: Date.now()
      }
    ]
  };

  await kv.put(`ticket_${chatId}_${ticketId}`, JSON.stringify(ticketData));
  await kv.delete(`pending_ticket_${chatId}`);

  // اطلاع‌رسانی به مدیر
  await notifyAdminNewTicket(ticketData);

  const successText = `✅ <b>تیکت ثبت شد!</b>

🆔 شماره تیکت: <code>${ticketId}</code>
📝 موضوع: ${pendingTicket.typeName}
📅 تاریخ: ${formatDate(Date.now())}

⏱️ پاسخ به زودی ارسال می‌شود
💬 برای مشاهده تیکت‌ها از منوی پشتیبانی استفاده کنید`;

  await sendMessage(chatId, successText, KEYBOARDS.backToSupport);
}

// نمایش تیکت‌های کاربر
async function showMyTickets(chatId, messageId, kv) {
  try {
    const userTicketsResult = await kv.list(`ticket_${chatId}_`);
    
    if (!userTicketsResult.keys || userTicketsResult.keys.length === 0) {
      const noTicketsText = `📂 <b>تیکت‌های من</b>

❌ هیچ تیکتی ثبت نکرده‌اید!

🎫 برای ثبت تیکت جدید دکمه زیر را بزنید.`;

      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🎫 ثبت تیکت جدید', callback_data: 'create_ticket' }],
            [{ text: '🔙 منوی پشتیبانی', callback_data: 'support_menu' }]
          ]
        }
      };

      await editMessage(chatId, messageId, noTicketsText, keyboard);
      return;
    }

    let ticketsText = `📂 <b>تیکت‌های من</b>\n\n`;
    const keyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    const tickets = [];
    for (const key of userTicketsResult.keys) {
      const ticket = await kv.get(key.name, 'json');
      if (ticket) {
        tickets.push(ticket);
      }
    }

    // مرتب‌سازی بر اساس تاریخ
    tickets.sort((a, b) => b.createdAt - a.createdAt);

    tickets.forEach((ticket, index) => {
      const statusEmoji = ticket.status === 'open' ? '🟢' : '🔴';
      const statusText = ticket.status === 'open' ? 'باز' : 'بسته';
      
      ticketsText += `${index + 1}️⃣ ${statusEmoji} <b>${ticket.typeName}</b>
🆔 ${ticket.id}
📝 ${ticket.subject}
📅 ${formatDate(ticket.createdAt)}
🔸 وضعیت: ${statusText}

`;

      keyboard.reply_markup.inline_keyboard.push([{
        text: `💬 ${ticket.typeName} (${statusText})`,
        callback_data: `view_ticket_${ticket.id}`
      }]);
    });

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🎫 ثبت تیکت جدید',
      callback_data: 'create_ticket'
    }]);

    keyboard.reply_markup.inline_keyboard.push([{
      text: '🔙 منوی پشتیبانی',
      callback_data: 'support_menu'
    }]);

    await editMessage(chatId, messageId, ticketsText, keyboard);

  } catch (error) {
    console.error('Error showing tickets:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش تیکت‌ها.', KEYBOARDS.backToSupport);
  }
}

// نمایش جزئیات تیکت
async function showTicketDetails(chatId, messageId, ticketId, kv) {
  try {
    const ticketKey = `ticket_${chatId}_${ticketId}`;
    const ticket = await kv.get(ticketKey, 'json');
    
    if (!ticket) {
      await editMessage(chatId, messageId, '❌ تیکت یافت نشد!', KEYBOARDS.backToSupport);
      return;
    }

    const statusEmoji = ticket.status === 'open' ? '🟢' : '🔴';
    const statusText = ticket.status === 'open' ? 'باز' : 'بسته';

    let ticketText = `💬 <b>تیکت ${ticket.typeName}</b>

🆔 شماره: <code>${ticket.id}</code>
📅 تاریخ: ${formatDate(ticket.createdAt)}
🔸 وضعیت: ${statusEmoji} ${statusText}

📝 <b>پیام‌ها:</b>

`;

    // نمایش پیام‌ها
    ticket.messages.forEach((msg, index) => {
      const fromEmoji = msg.from === 'user' ? '👤' : '👨‍💼';
      const fromText = msg.from === 'user' ? 'شما' : 'پشتیبانی';
      const time = formatDateTime(msg.timestamp);
      
      ticketText += `${fromEmoji} <b>${fromText}</b> - ${time}
${msg.message}

`;
    });

    const keyboardButtons = [];
    
    if (ticket.status === 'open') {
      keyboardButtons.push([
        { text: '💬 پاسخ دادن', callback_data: `reply_ticket_user_${ticket.id}` },
        { text: '🔒 بستن تیکت', callback_data: `close_ticket_user_${ticket.id}` }
      ]);
    }
    
    keyboardButtons.push([{ text: '🔙 تیکت‌های من', callback_data: 'my_tickets' }]);

    const keyboard = {
      reply_markup: {
        inline_keyboard: keyboardButtons
      }
    };

    await editMessage(chatId, messageId, ticketText, keyboard);

  } catch (error) {
    console.error('Error showing ticket details:', error);
    await editMessage(chatId, messageId, '❌ خطا در نمایش تیکت.', KEYBOARDS.backToSupport);
  }
}

// پاسخ کاربر به تیکت
async function userReplyTicket(chatId, messageId, ticketId, kv) {
  const ticketKey = `ticket_${chatId}_${ticketId}`;
  const ticket = await kv.get(ticketKey, 'json');
  
  if (!ticket || ticket.status !== 'open') {
    await editMessage(chatId, messageId, '❌ تیکت یافت نشد یا بسته است!', KEYBOARDS.backToSupport);
    return;
  }

  // ذخیره تیکت در انتظار پاسخ کاربر
  await kv.put(`pending_user_reply_${chatId}`, JSON.stringify({
    ticketId: ticketId,
    ticketKey: ticketKey,
    userChatId: chatId,
    userMessageId: messageId,
    createdAt: Date.now()
  }));

  const replyText = `💬 <b>پاسخ به تیکت</b>

🆔 تیکت: <code>${ticketId}</code>
📝 موضوع: ${ticket.typeName}

📝 پیام پاسخ خود را بنویسید:

💡 حداکثر 500 کاراکتر
📤 منتظر پاسخ شما هستیم...`;

  await editMessage(chatId, messageId, replyText, KEYBOARDS.backToSupport);
}

// پردازش پاسخ کاربر
async function processUserTicketReply(chatId, messageText, kv) {
  const pendingReply = await kv.get(`pending_user_reply_${chatId}`, 'json');
  
  if (!pendingReply) {
    return; // پاسخی در انتظار نیست
  }

  if (messageText.length > 500) {
    await sendMessage(chatId, '❌ پیام بیش از 500 کاراکتر است!');
    return;
  }

  const ticket = await kv.get(pendingReply.ticketKey, 'json');
  
  if (!ticket || ticket.status !== 'open') {
    await sendMessage(chatId, '❌ تیکت یافت نشد یا بسته است!');
    await kv.delete(`pending_user_reply_${chatId}`);
    return;
  }

  // اضافه کردن پاسخ
  ticket.messages.push({
    from: 'user',
    message: messageText,
    timestamp: Date.now()
  });

  await kv.put(pendingReply.ticketKey, JSON.stringify(ticket));
  await kv.delete(`pending_user_reply_${chatId}`);

  // اطلاع‌رسانی به مدیر
  const adminNotification = `💬 <b>پاسخ جدید در تیکت</b>

🆔 تیکت: <code>${ticket.id}</code>
👤 کاربر: <code>${ticket.chatId}</code>
📝 موضوع: ${ticket.typeName}

💬 <b>پیام جدید:</b>
${messageText}

📅 ${formatDateTime(Date.now())}`;

  const adminKeyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '💬 پاسخ دادن', callback_data: `reply_ticket_${ticket.id}` }],
        [{ text: '🔒 بستن تیکت', callback_data: `close_ticket_${ticket.id}` }]
      ]
    }
  };

  await sendMessage(ADMIN_ID, adminNotification, adminKeyboard);

  // تأیید برای کاربر
  await sendMessage(chatId, `✅ پاسخ شما برای تیکت ${ticket.id} ثبت شد!

⏰ منتظر پاسخ پشتیبانی باشید.`, KEYBOARDS.backToSupport);
}

// بستن تیکت توسط کاربر
async function closeTicketByUser(chatId, messageId, ticketId, kv) {
  try {
    const ticketKey = `ticket_${chatId}_${ticketId}`;
    const ticket = await kv.get(ticketKey, 'json');
    
    if (!ticket) {
      await editMessage(chatId, messageId, '❌ تیکت یافت نشد!', KEYBOARDS.backToSupport);
      return;
    }

    if (ticket.status !== 'open') {
      await editMessage(chatId, messageId, '❌ این تیکت قبلاً بسته شده است!', KEYBOARDS.backToSupport);
      return;
    }

    // بستن تیکت
    ticket.status = 'closed';
    ticket.closedAt = Date.now();
    ticket.closedBy = 'user';

    await kv.put(ticketKey, JSON.stringify(ticket));

    // اطلاع‌رسانی به مدیر
    const adminNotification = `🔒 <b>تیکت بسته شد</b>

🆔 تیکت: <code>${ticket.id}</code>
👤 کاربر: <code>${ticket.chatId}</code>
📝 موضوع: ${ticket.typeName}

✅ تیکت توسط کاربر بسته شد
📅 ${formatDateTime(Date.now())}`;

    await sendMessage(ADMIN_ID, adminNotification);

    // تأیید برای کاربر
    const confirmText = `🔒 <b>تیکت بسته شد</b>

🆔 تیکت: <code>${ticketId}</code>
📝 موضوع: ${ticket.typeName}

✅ تیکت شما با موفقیت بسته شد
📅 ${formatDateTime(Date.now())}

💬 برای مسائل جدید می‌توانید تیکت جدید ثبت کنید`;

    await editMessage(chatId, messageId, confirmText, KEYBOARDS.backToSupport);

  } catch (error) {
    console.error('Error closing ticket by user:', error);
    await editMessage(chatId, messageId, '❌ خطا در بستن تیکت.', KEYBOARDS.backToSupport);
  }
}

// اطلاع‌رسانی تیکت جدید به مدیر
async function notifyAdminNewTicket(ticketData) {
  try {
    const adminText = `🎫 <b>تیکت جدید دریافت شد!</b>

🆔 شماره تیکت: <code>${ticketData.id}</code>
👤 کاربر: <code>${ticketData.chatId}</code>
📝 موضوع: ${ticketData.typeName}
📅 تاریخ: ${formatDateTime(ticketData.createdAt)}

💬 <b>پیام:</b>
${ticketData.message}

🌐 <b>پنل وب:</b> آدرس ورکر + /admin`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '💬 پاسخ دادن', callback_data: `reply_ticket_${ticketData.id}` }],
          [{ text: '🔒 بستن تیکت', callback_data: `close_ticket_${ticketData.id}` }]
        ]
      }
    };

    await sendMessage(ADMIN_ID, adminText, keyboard);

  } catch (error) {
    console.error('Error notifying admin about new ticket:', error);
  }
}

// پاسخ مدیر به تیکت
async function adminReplyTicket(chatId, messageId, ticketId, kv) {
  if (!isAdmin(chatId)) return;

  // ذخیره تیکت در انتظار پاسخ
  await kv.put(`pending_reply_${chatId}`, JSON.stringify({
    ticketId: ticketId,
    adminChatId: chatId,
    adminMessageId: messageId,
    createdAt: Date.now()
  }));

  const replyText = `💬 <b>پاسخ به تیکت</b>

🆔 تیکت: <code>${ticketId}</code>

📝 پیام پاسخ خود را بنویسید:

💡 حداکثر 1000 کاراکتر
📤 منتظر پاسخ شما هستیم...`;

  await editMessage(chatId, messageId, replyText, {});
}

// پردازش پاسخ مدیر
async function processAdminReply(chatId, messageText, kv) {
  const pendingReply = await kv.get(`pending_reply_${chatId}`, 'json');
  
  if (!pendingReply) {
    return; // پاسخی در انتظار نیست
  }

  if (messageText.length > 1000) {
    await sendMessage(chatId, '❌ پیام بیش از 1000 کاراکتر است!');
    return;
  }

  // پیدا کردن تیکت
  const allTickets = await kv.list('ticket_');
  let ticketData = null;
  let ticketKey = null;

  for (const key of allTickets.keys) {
    const ticket = await kv.get(key.name, 'json');
    if (ticket && ticket.id === pendingReply.ticketId) {
      ticketData = ticket;
      ticketKey = key.name;
      break;
    }
  }

  if (!ticketData) {
    await sendMessage(chatId, '❌ تیکت یافت نشد!');
    await kv.delete(`pending_reply_${chatId}`);
    return;
  }

  // اضافه کردن پاسخ
  ticketData.messages.push({
    from: 'admin',
    message: messageText,
    timestamp: Date.now()
  });

  await kv.put(ticketKey, JSON.stringify(ticketData));
  await kv.delete(`pending_reply_${chatId}`);

  // ارسال پاسخ به کاربر
  const userNotification = `💬 <b>پاسخ پشتیبانی</b>

🆔 تیکت: <code>${ticketData.id}</code>
📝 موضوع: ${ticketData.typeName}

👨‍💼 <b>پاسخ پشتیبانی:</b>
${messageText}

📅 ${formatDateTime(Date.now())}`;

  const userKeyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '💬 مشاهده تیکت', callback_data: `view_ticket_${ticketData.id}` }],
        [{ text: '🎫 تیکت‌های من', callback_data: 'my_tickets' }]
      ]
    }
  };

  await sendMessage(ticketData.chatId, userNotification, userKeyboard);

  // تأیید برای مدیر
  await sendMessage(chatId, `✅ پاسخ شما برای تیکت ${ticketData.id} ارسال شد!`);
}

// بستن تیکت توسط مدیر
async function closeTicketByAdmin(chatId, messageId, ticketId, kv) {
  if (!isAdmin(chatId)) return;

  // پیدا کردن تیکت
  const allTickets = await kv.list('ticket_');
  let ticketData = null;
  let ticketKey = null;

  for (const key of allTickets.keys) {
    const ticket = await kv.get(key.name, 'json');
    if (ticket && ticket.id === ticketId) {
      ticketData = ticket;
      ticketKey = key.name;
      break;
    }
  }

  if (!ticketData) {
    await editMessage(chatId, messageId, '❌ تیکت یافت نشد!', {});
    return;
  }

  // بستن تیکت
  ticketData.status = 'closed';
  ticketData.closedAt = Date.now();
  ticketData.closedBy = 'admin';

  await kv.put(ticketKey, JSON.stringify(ticketData));

  // اطلاع‌رسانی به کاربر
  const userNotification = `🔒 <b>تیکت بسته شد</b>

🆔 تیکت: <code>${ticketData.id}</code>
📝 موضوع: ${ticketData.typeName}

✅ تیکت شما توسط پشتیبانی بسته شد
📅 ${formatDateTime(Date.now())}

💬 برای مسائل جدید می‌توانید تیکت جدید ثبت کنید`;

  await sendMessage(ticketData.chatId, userNotification, KEYBOARDS.backToSupport);

  // تأیید برای مدیر
  const adminConfirm = `✅ <b>تیکت بسته شد</b>

🆔 تیکت: <code>${ticketId}</code>
👤 کاربر: <code>${ticketData.chatId}</code>
📝 موضوع: ${ticketData.typeName}`;

  await editMessage(chatId, messageId, adminConfirm, {});
}

// ارسال رسید به ادمین
async function sendReceiptToAdmin(messageData, referenceId, type) {
  try {
    const caption = `📄 <b>رسید ${type}</b>\n\n🆔 شناسه: <code>${referenceId}</code>\n📅 زمان: ${formatDateTime(Date.now())}`;
    
    if (messageData.photo && messageData.photo.length > 0) {
      // ارسال عکس رسید
      const photo = messageData.photo[messageData.photo.length - 1]; // بزرگترین سایز
      await sendPhoto(ADMIN_ID, photo.file_id, caption);
    } else if (messageData.document) {
      // ارسال فایل رسید
      const url = `${TELEGRAM_API}/sendDocument`;
      const payload = {
        chat_id: ADMIN_ID,
        document: messageData.document.file_id,
        caption: caption,
        parse_mode: 'HTML'
      };
      
      await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    } else if (messageData.text) {
      // اگر متن باشه (شاید شماره تراکنش)
      await sendMessage(ADMIN_ID, `${caption}\n\n📝 متن رسید:\n${messageData.text}`);
    } else {
      await sendMessage(ADMIN_ID, `${caption}\n\n⚠️ نوع فایل رسید شناسایی نشد`);
    }
    
    return true;
  } catch (error) {
    console.error('Error sending receipt to admin:', error);
    return false;
  }
}
// ارسال رسید پرداخت به ادمین - بهبود یافته
async function notifyAdminNewPayment(orderData, receiptData = null) {
  try {
    const adminText = `🔔 <b>رسید پرداخت جدید!</b>

🆔 سفارش: <code>${orderData.id}</code>
👤 کاربر: <code>${orderData.chatId}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}
${orderData.type === 'renewal' ? `🔄 نوع: تمدید سرویس\n👤 کاربری: ${orderData.serviceData.username}\n` : `🖥️ سرور: ${orderData.serverName}\n`}

🕐 زمان: ${formatDateTime(orderData.paymentSubmittedAt)}`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '✅ تأیید', callback_data: `approve_payment_${orderData.id}` },
            { text: '❌ رد', callback_data: `reject_payment_${orderData.id}` }
          ]
        ]
      }
    };

    // ارسال متن اولیه
    const sentMessage = await sendMessage(ADMIN_ID, adminText, keyboard);
    if (!sentMessage.ok) throw new Error('Failed to send message to admin');

    // ارسال رسید
    if (receiptData) {
      await sendReceiptToAdmin(receiptData, orderData.id, "سفارش");
    }

    return true;
  } catch (error) {
    console.error('Error notifying admin about payment:', error);
    return false;
  }
}

// ارسال رسید شارژ به ادمین - بهبود یافته
async function notifyAdminNewChargePayment(chargeData, receiptData = null) {
  try {
    const adminText = `💰 <b>رسید شارژ کیف پول جدید!</b>

🆔 شارژ: <code>${chargeData.id}</code>
👤 کاربر: <code>${chargeData.chatId}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

🕐 زمان: ${formatDateTime(chargeData.paymentSubmittedAt)}`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '✅ تأیید شارژ', callback_data: `approve_charge_${chargeData.id}` },
            { text: '❌ رد شارژ', callback_data: `reject_charge_${chargeData.id}` }
          ]
        ]
      }
    };

    // ارسال متن اولیه
    const sentMessage = await sendMessage(ADMIN_ID, adminText, keyboard);
    if (!sentMessage.ok) throw new Error('Failed to send message to admin');

    // ارسال رسید
    if (receiptData) {
      await sendReceiptToAdmin(receiptData, chargeData.id, "شارژ");
    }

    return true;
  } catch (error) {
    console.error('Error notifying admin about charge:', error);
    return false;
  }
}

// ایجاد سرویس در سرور با اینباند کاربر مرجع
async function createServerService(orderData, kv) {
  try {
    const servers = await getServers(kv);
    const server = servers[orderData.serverId];
    
    if (!server) {
      return { success: false, error: 'سرور یافت نشد' };
    }

    const api = new MarzbanAPI(server.baseUrl);
    const loginResult = await api.login(server.username, server.password);
    
    if (!loginResult.success) {
      return { success: false, error: `خطا در اتصال: ${loginResult.error}` };
    }

    // دریافت تنظیمات اینباند
    const inboundSettings = await getInboundSettings(kv);
    let inbounds = {};

    if (inboundSettings.referenceUsername) {
      const refUserResult = await api.getUser(inboundSettings.referenceUsername);
      if (refUserResult.success && refUserResult.data.inbounds) {
        inbounds = refUserResult.data.inbounds;
      } else {
        const inboundsResult = await api.getInbounds();
        if (inboundsResult.success) {
          inboundsResult.data.forEach(inbound => {
            if (inbound.type && inbound.tag) {
              const protocol = inbound.type.toLowerCase();
              if (!inbounds[protocol]) {
                inbounds[protocol] = [];
              }
              inbounds[protocol].push(inbound.tag);
            }
          });
        }
      }
    } else {
      const inboundsResult = await api.getInbounds();
      if (!inboundsResult.success) {
        return { success: false, error: 'نتوانست اینباندها را دریافت کند' };
      }

      inboundsResult.data.forEach(inbound => {
        if (inbound.type && inbound.tag) {
          const protocol = inbound.type.toLowerCase();
          if (!inbounds[protocol]) {
            inbounds[protocol] = [];
          }
          inbounds[protocol].push(inbound.tag);
        }
      });
    }

    const username = generateUsername(orderData.chatId, orderData.plan.id);
    const expireTimestamp = Math.floor(Date.now() / 1000) + (orderData.plan.duration * 24 * 60 * 60);
    
    const userData = {
      username: username,
      data_limit: orderData.plan.dataLimit ? orderData.plan.dataLimit * 1024 * 1024 * 1024 : 0,
      expire: expireTimestamp,
      status: 'active',
      inbounds: inbounds,
      proxies: {}
    };

    Object.keys(inbounds).forEach(protocol => {
      userData.proxies[protocol] = {};
    });

    const createResult = await api.createUser(userData);
    
    if (!createResult.success) {
      return { success: false, error: createResult.error };
    }

    await new Promise(resolve => setTimeout(resolve, 2000)); // کاهش زمان انتظار
    
    const userResult = await api.getUser(username);
    let configUrl = null;
    
    if (userResult.success && userResult.data.subscription_url) {
      configUrl = userResult.data.subscription_url.startsWith('http') ? 
                 userResult.data.subscription_url : 
                 `${api.baseUrl}${userResult.data.subscription_url}`;
    }

    const serviceId = generateServiceId();
    const serviceData = {
      serviceId: serviceId,
      chatId: orderData.chatId,
      username: username,
      planName: orderData.plan.name,
      planId: orderData.plan.id,
      dataLimit: orderData.plan.dataLimit,
      duration: orderData.plan.duration,
      expireTimestamp: expireTimestamp * 1000,
      configUrl: configUrl,
      status: 'active',
      createdAt: Date.now(),
      orderId: orderData.id,
      serverId: orderData.serverId,
      serverName: orderData.serverName
    };

    await kv.put(`service_${orderData.chatId}_${serviceId}`, JSON.stringify(serviceData));

    return { 
      success: true, 
      serviceData: serviceData 
    };

  } catch (error) {
    console.error('Error creating server service:', error);
    return { success: false, error: error.message };
  }
}

// تمدید سرویس موجود
async function renewExistingService(orderData, kv) {
  try {
    const servers = await getServers(kv);
    const server = servers[orderData.serviceData.serverId];
    
    if (!server) {
      return { success: false, error: 'سرور یافت نشد' };
    }

    const api = new MarzbanAPI(server.baseUrl);
    const loginResult = await api.login(server.username, server.password);
    
    if (!loginResult.success) {
      return { success: false, error: `خطا در اتصال: ${loginResult.error}` };
    }

    // محاسبه زمان انقضای جدید
    const currentExpire = Math.max(
      Math.floor(orderData.serviceData.expireTimestamp / 1000),
      Math.floor(Date.now() / 1000)
    );
    const newExpire = currentExpire + (orderData.plan.duration * 24 * 60 * 60);
    
    // محاسبه حجم جدید
    let newDataLimit = 0;
    if (orderData.plan.dataLimit > 0) {
      const currentLimit = orderData.serviceData.dataLimit || 0;
      newDataLimit = (currentLimit + orderData.plan.dataLimit) * 1024 * 1024 * 1024;
    }

    const updateData = {
      expire: newExpire,
      data_limit: newDataLimit,
      status: 'active'
    };

    const updateResult = await api.modifyUser(orderData.serviceData.username, updateData);
    
    if (!updateResult.success) {
      return { success: false, error: updateResult.error };
    }

    // بروزرسانی داده‌های سرویس
    const serviceResult = await findServiceById(orderData.chatId, orderData.serviceId, kv);
    if (serviceResult) {
      const updatedServiceData = {
        ...orderData.serviceData,
        expireTimestamp: newExpire * 1000,
        dataLimit: orderData.serviceData.dataLimit + (orderData.plan.dataLimit || 0),
        renewedAt: Date.now(),
        lastRenewalPlan: orderData.plan.name
      };

      await kv.put(serviceResult.key, JSON.stringify(updatedServiceData));

      return { 
        success: true, 
        serviceData: updatedServiceData 
      };
    }

    return { success: false, error: 'سرویس یافت نشد برای بروزرسانی' };

  } catch (error) {
    console.error('Error renewing service:', error);
    return { success: false, error: error.message };
  }
}

// تأیید پرداخت توسط مدیر
async function approvePayment(chatId, messageId, orderId, kv) {
  if (!isAdmin(chatId)) return;

  try {
    const orderData = await kv.get(`order_${orderId}`, 'json');
    
    if (!orderData) {
      await editMessage(chatId, messageId, '❌ سفارش یافت نشد!', {});
      return;
    }

    if (orderData.status !== 'payment_submitted') {
      await editMessage(chatId, messageId, '❌ وضعیت سفارش قابل تأیید نیست!', {});
      return;
    }

    // ارسال پیام در حال پردازش
    const processingMessage = await sendMessage(ADMIN_ID, '⏳ در حال پردازش سفارش...');

    let serviceResult;
    
    if (orderData.type === 'renewal') {
      serviceResult = await renewExistingService(orderData, kv);
    } else {
      serviceResult = await createServerService(orderData, kv);
    }
    
    // حذف پیام پردازش
    await deleteMessage(ADMIN_ID, processingMessage.result.message_id);
    
    if (!serviceResult.success) {
      await editMessage(chatId, messageId, 
        `❌ خطا در ${orderData.type === 'renewal' ? 'تمدید' : 'ایجاد'} سرویس: ${serviceResult.error}`,
        {}
      );
      return;
    }

    orderData.status = 'completed';
    orderData.completedAt = Date.now();
    orderData.serviceData = serviceResult.serviceData;
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    await kv.delete(`user_order_${orderData.chatId}`);
    await kv.delete(`selected_plan_${orderData.chatId}`);

    if (orderData.type === 'renewal') {
      await notifyUserRenewalComplete(orderData, serviceResult.serviceData);
    } else {
      await notifyUserServiceReady(orderData, serviceResult.serviceData);
    }

    const successText = `✅ <b>پرداخت تأیید شد!</b>

🆔 سفارش: <code>${orderId}</code>
👤 کاربر: <code>${orderData.chatId}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}
🔧 نوع: ${orderData.type === 'renewal' ? 'تمدید سرویس' : 'ایجاد سرویس جدید'}

🔧 ${orderData.type === 'renewal' ? 'سرویس تمدید شد' : 'سرویس ایجاد شد'} و برای کاربر ارسال شد.`;

    await editMessage(chatId, messageId, successText, {});

  } catch (error) {
    console.error('Error approving payment:', error);
    await editMessage(chatId, messageId, 
      `❌ خطا در تأیید پرداخت: ${error.message}`,
      {}
    );
  }
}

// تأیید شارژ کیف پول
async function approveCharge(chatId, messageId, chargeId, kv) {
  if (!isAdmin(chatId)) return;

  try {
    const chargeData = await kv.get(`wallet_charge_${chargeId}`, 'json');
    
    if (!chargeData) {
      await editMessage(chatId, messageId, '❌ شارژ یافت نشد!', {});
      return;
    }

    if (chargeData.status !== 'payment_submitted') {
      await editMessage(chatId, messageId, '❌ وضعیت شارژ قابل تأیید نیست!', {});
      return;
    }

    // اضافه کردن مبلغ به کیف پول
    const newBalance = await updateWalletBalance(chargeData.chatId, chargeData.amount, kv);
    if (newBalance === false) {
      await editMessage(chatId, messageId, '❌ خطا در افزودن موجودی!', {});
      return;
    }

    // ثبت تراکنش
    await recordWalletTransaction(chargeData.chatId, chargeData.amount, 'charge', `شارژ کیف پول - ${chargeId}`, kv);

    // بروزرسانی وضعیت شارژ
    chargeData.status = 'completed';
    chargeData.completedAt = Date.now();
    await kv.put(`wallet_charge_${chargeId}`, JSON.stringify(chargeData));

    await kv.delete(`user_charge_${chargeData.chatId}`);

    // اطلاع‌رسانی به کاربر
    const userNotification = `✅ <b>شارژ کیف پول تأیید شد!</b>

🆔 شارژ: <code>${chargeId}</code>
💰 مبلغ شارژ: ${formatPrice(chargeData.amount)}
💳 موجودی جدید: ${formatPrice(newBalance)}

🎉 کیف پول شما شارژ شد!

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    await sendMessage(chargeData.chatId, userNotification, KEYBOARDS.backToWallet);

    const successText = `✅ <b>شارژ تأیید شد!</b>

🆔 شارژ: <code>${chargeId}</code>
👤 کاربر: <code>${chargeData.chatId}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

💳 مبلغ به کیف پول کاربر اضافه شد.`;

    await editMessage(chatId, messageId, successText, {});

  } catch (error) {
    console.error('Error approving charge:', error);
    await editMessage(chatId, messageId, 
      `❌ خطا در تأیید شارژ: ${error.message}`,
      {}
    );
  }
}

// رد شارژ کیف پول
async function rejectCharge(chatId, messageId, chargeId, kv) {
  if (!isAdmin(chatId)) return;

  try {
    const chargeData = await kv.get(`wallet_charge_${chargeId}`, 'json');
    
    if (!chargeData) {
      await editMessage(chatId, messageId, '❌ شارژ یافت نشد!', {});
      return;
    }

    chargeData.status = 'rejected';
    chargeData.rejectedAt = Date.now();
    await kv.put(`wallet_charge_${chargeId}`, JSON.stringify(chargeData));

    await kv.delete(`user_charge_${chargeData.chatId}`);

    const rejectionText = `❌ <b>شارژ تأیید نشد</b>

🆔 شارژ: <code>${chargeId}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

🔍 دلایل احتمالی:
• مبلغ کامل نبوده
• شماره کارت اشتباه
• رسید نامعتبر

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    const userKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '💳 شارژ مجدد', callback_data: 'wallet_charge' }],
          [{ text: '💬 تماس با پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
        ]
      }
    };

    await sendMessage(chargeData.chatId, rejectionText, userKeyboard);

    const successText = `❌ <b>شارژ رد شد!</b>

🆔 شارژ: <code>${chargeId}</code>
👤 کاربر: <code>${chargeData.chatId}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

📤 پیام رد به کاربر ارسال شد.`;

    await editMessage(chatId, messageId, successText, {});

  } catch (error) {
    console.error('Error rejecting charge:', error);
    await editMessage(chatId, messageId, 
      `❌ خطا در رد شارژ: ${error.message}`,
      {}
    );
  }
}

// رد پرداخت توسط مدیر
async function rejectPaymentByAdmin(chatId, messageId, orderId, kv) {
  if (!isAdmin(chatId)) return;

  try {
    const orderData = await kv.get(`order_${orderId}`, 'json');
    
    if (!orderData) {
      await editMessage(chatId, messageId, '❌ سفارش یافت نشد!', {});
      return;
    }

    orderData.status = 'rejected';
    orderData.rejectedAt = Date.now();
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    await kv.delete(`user_order_${orderData.chatId}`);
    await kv.delete(`selected_plan_${orderData.chatId}`);

    const rejectionText = `❌ <b>پرداخت تأیید نشد</b>

🆔 سفارش: <code>${orderId}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}
${orderData.type === 'renewal' ? `🔄 نوع: تمدید سرویس\n` : ''}

🔍 دلایل احتمالی:
• مبلغ کامل نبوده
• شماره کارت اشتباه
• رسید نامعتبر

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    const userKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🛒 خرید مجدد', callback_data: 'buy_service' }],
          [{ text: '💬 تماس با پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
        ]
      }
    };

    await sendMessage(orderData.chatId, rejectionText, userKeyboard);

    const successText = `❌ <b>پرداخت رد شد!</b>

🆔 سفارش: <code>${orderId}</code>
👤 کاربر: <code>${orderData.chatId}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}

📤 پیام رد به کاربر ارسال شد.`;

    await editMessage(chatId, messageId, successText, {});

  } catch (error) {
    console.error('Error rejecting payment:', error);
    await editMessage(chatId, messageId, 
      `❌ خطا در رد پرداخت: ${error.message}`,
      {}
    );
  }
}

async function notifyUserRenewalComplete(orderData, serviceData) {
  try {
    const notificationText = `🎉 <b>تمدید تکمیل شد!</b>

✅ پرداخت تأیید شد

📦 <b>جزئیات تمدید:</b>
🆔 سفارش: <code>${orderData.id}</code>
📋 تمدید: ${orderData.plan.name}
👤 کاربری: <code>${serviceData.username}</code>
⏰ زمان اضافه شده: ${orderData.plan.duration} روز
📊 حجم اضافه شده: ${orderData.plan.dataLimit ? orderData.plan.dataLimit + ' گیگ' : 'نامحدود'}
📅 انقضای جدید: ${formatDate(serviceData.expireTimestamp)}

💡 زمان و حجم جدید به سرویس قبلی اضافه شده است.

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }],
          [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
        ]
      }
    };

    await sendMessage(orderData.chatId, notificationText, keyboard);

  } catch (error) {
    console.error('Error notifying user about renewal:', error);
  }
}

// API تأیید پرداخت
async function approvePaymentAPI(orderId, kv) {
  try {
    const orderData = await kv.get(`order_${orderId}`, 'json');
    
    if (!orderData) {
      return { success: false, error: 'سفارش یافت نشد' };
    }

    if (orderData.status !== 'payment_submitted') {
      return { success: false, error: 'وضعیت سفارش قابل تأیید نیست' };
    }

    let serviceResult;
    
    if (orderData.type === 'renewal') {
      serviceResult = await renewExistingService(orderData, kv);
    } else {
      serviceResult = await createServerService(orderData, kv);
    }
    
    if (!serviceResult.success) {
      return { success: false, error: serviceResult.error };
    }

    orderData.status = 'completed';
    orderData.completedAt = Date.now();
    orderData.serviceData = serviceResult.serviceData;
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    await kv.delete(`user_order_${orderData.chatId}`);
    await kv.delete(`selected_plan_${orderData.chatId}`);

    if (orderData.type === 'renewal') {
      await notifyUserRenewalComplete(orderData, serviceResult.serviceData);
    } else {
      await notifyUserServiceReady(orderData, serviceResult.serviceData);
    }

    return { success: true, message: 'پرداخت تأیید شد' };

  } catch (error) {
    console.error('Error approving payment API:', error);
    return { success: false, error: error.message };
  }
}

// API رد پرداخت  
async function rejectPaymentAPI(orderId, kv) {
  try {
    const orderData = await kv.get(`order_${orderId}`, 'json');
    
    if (!orderData) {
      return { success: false, error: 'سفارش یافت نشد' };
    }

    orderData.status = 'rejected';
    orderData.rejectedAt = Date.now();
    await kv.put(`order_${orderId}`, JSON.stringify(orderData));

    await kv.delete(`user_order_${orderData.chatId}`);
    await kv.delete(`selected_plan_${orderData.chatId}`);

    const rejectionText = `❌ <b>پرداخت تأیید نشد</b>

🆔 سفارش: <code>${orderId}</code>
📦 پلن: ${orderData.plan.name}
💰 مبلغ: ${formatPrice(orderData.plan.price)}
${orderData.type === 'renewal' ? `🔄 نوع: تمدید سرویس\n` : ''}

🔍 دلایل احتمالی:
• مبلغ کامل نبوده
• شماره کارت اشتباه
• رسید نامعتبر

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    const userKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🛒 خرید مجدد', callback_data: 'buy_service' }],
          [{ text: '💬 تماس با پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
        ]
      }
    };

    await sendMessage(orderData.chatId, rejectionText, userKeyboard);

    return { success: true, message: 'پرداخت رد شد' };

  } catch (error) {
    console.error('Error rejecting payment API:', error);
    return { success: false, error: error.message };
  }
}

// اطلاع‌رسانی به کاربر - ارسال کانفیگ جدا
async function notifyUserServiceReady(orderData, serviceData) {
  try {
    // ارسال کانفیگ جداگانه بدون دکمه
    if (serviceData.configUrl) {
      const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=400x400&format=png&data=${encodeURIComponent(serviceData.configUrl)}`;
      
      const configText = `🔗 <b>کانفیگ سرویس شما</b>

👤 نام کاربری: <code>${serviceData.username}</code>

🔗 <b>لینک اشتراک:</b>
<code>${serviceData.configUrl}</code>

💡 <b>نحوه استفاده:</b>
• QR کد را اسکن کنید یا لینک را کپی کنید
• در اپلیکیشن VPN وارد کنید

📱 <b>اپلیکیشن‌های پیشنهادی:</b>
🤖 اندروید: V2rayNG
🍎 آیفون: Fair VPN یا Shadowrocket
💻 ویندوز: V2rayN
🖥️ مک: ClashX
🏠 منوی اصلی: /start`;

      await sendPhoto(orderData.chatId, qrUrl, configText);
    }

    // پیام موفقیت جداگانه با دکمه‌ها
    const successText = `🎉 <b>سرویس ${orderData.plan.name} با موفقیت ساخته شد!</b>

📦 <b>جزئیات سرویس:</b>
🆔 سفارش: <code>${orderData.id}</code>
👤 نام کاربری: <code>${serviceData.username}</code>
📊 حجم: ${orderData.plan.dataLimit ? orderData.plan.dataLimit + ' گیگابایت' : 'نامحدود'}
⏰ مدت: ${orderData.plan.duration} روز
📅 تاریخ انقضا: ${formatDate(serviceData.expireTimestamp)}
🖥️ سرور: ${orderData.serverName}

⏰ <b>زمان ساخت:</b> ${formatDateTime(Date.now())}

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '📱 سرویس‌های من', callback_data: 'my_services' }],
          [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
        ]
      }
    };

    await sendMessage(orderData.chatId, successText, keyboard);

  } catch (error) {
    console.error('Error notifying user:', error);
  }
}

// محاسبه آمار درآمد
async function calculateRevenue(kv) {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayTimestamp = today.getTime();

    const ordersResult = await kv.list('order_ORD_');
    let todayRevenue = 0;
    let todayOrders = 0;
    let totalRevenue = 0;

    for (const key of ordersResult.keys) {
      const order = await kv.get(key.name, 'json');
      if (order && order.status === 'completed') {
        totalRevenue += order.plan.price;
        
        if (order.completedAt >= todayTimestamp) {
          todayRevenue += order.plan.price;
          todayOrders++;
        }
      }
    }

    return {
      todayRevenue,
      todayOrders,
      totalRevenue
    };
  } catch (error) {
    console.error('Error calculating revenue:', error);
    return { todayRevenue: 0, todayOrders: 0, totalRevenue: 0 };
  }
}

// تابع نمایش پنل مدیریت وب
function getAdminWebPanel() {
  return `<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>پنل مدیریت ARDISK VPN</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100;200;300;400;500;600;700;800;900&display=swap');
        * { 
            font-family: 'Vazirmatn', 'Tahoma', Arial, sans-serif !important;
        }
        .dark { background: #1a1a1a; color: #ffffff; }
        .tab-button.active {
            color: #3B82F6;
            border-color: #3B82F6;
        }
        .tab-button {
            color: #6B7280;
            border-color: transparent;
            transition: all 0.2s;
        }
        .tab-button:hover {
            color: #3B82F6;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .dark .modal-content {
            background-color: #374151;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen">
    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 shadow-lg border-b border-gray-200 dark:border-gray-700">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center py-4">
                <div class="flex items-center">
                    <i class="fas fa-shield-alt text-2xl text-blue-600 ml-3"></i>
                    <h1 class="text-2xl font-bold text-gray-900 dark:text-white">پنل مدیریت ARDISK VPN</h1>
                </div>
                <div class="flex items-center space-x-4 space-x-reverse">
                    <span class="text-sm text-gray-600 dark:text-gray-300">مدیر سیستم</span>
                    <button onclick="logout()" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors">
                        <i class="fas fa-sign-out-alt ml-2"></i>خروج
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Stats Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6 mb-8">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <div class="flex items-center">
                    <div class="p-3 rounded-full bg-blue-100 dark:bg-blue-900">
                        <i class="fas fa-shopping-cart text-blue-600 dark:text-blue-400"></i>
                    </div>
                    <div class="mr-4">
                        <p class="text-sm font-medium text-gray-600 dark:text-gray-400">سفارش‌های امروز</p>
                        <p class="text-2xl font-semibold text-gray-900 dark:text-white" id="todayOrders">0</p>
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <div class="flex items-center">
                    <div class="p-3 rounded-full bg-green-100 dark:bg-green-900">
                        <i class="fas fa-money-bill-wave text-green-600 dark:text-green-400"></i>
                    </div>
                    <div class="mr-4">
                        <p class="text-sm font-medium text-gray-600 dark:text-gray-400">درآمد امروز</p>
                        <p class="text-2xl font-semibold text-gray-900 dark:text-white" id="todayRevenue">0</p>
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <div class="flex items-center">
                    <div class="p-3 rounded-full bg-yellow-100 dark:bg-yellow-900">
                        <i class="fas fa-clock text-yellow-600 dark:text-yellow-400"></i>
                    </div>
                    <div class="mr-4">
                        <p class="text-sm font-medium text-gray-600 dark:text-gray-400">در انتظار تأیید</p>
                        <p class="text-2xl font-semibold text-gray-900 dark:text-white" id="pendingPayments">0</p>
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <div class="flex items-center">
                    <div class="p-3 rounded-full bg-orange-100 dark:bg-orange-900">
                        <i class="fas fa-wallet text-orange-600 dark:text-orange-400"></i>
                    </div>
                    <div class="mr-4">
                        <p class="text-sm font-medium text-gray-600 dark:text-gray-400">شارژ در انتظار</p>
                        <p class="text-2xl font-semibold text-gray-900 dark:text-white" id="pendingCharges">0</p>
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <div class="flex items-center">
                    <div class="p-3 rounded-full bg-purple-100 dark:bg-purple-900">
                        <i class="fas fa-tickets text-purple-600 dark:text-purple-400"></i>
                    </div>
                    <div class="mr-4">
                        <p class="text-sm font-medium text-gray-600 dark:text-gray-400">تیکت‌های باز</p>
                        <p class="text-2xl font-semibold text-gray-900 dark:text-white" id="openTickets">0</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
            <div class="border-b border-gray-200 dark:border-gray-700">
                <nav class="-mb-px flex overflow-x-auto">
                    <button onclick="showTab('payments')" id="paymentsTab" class="tab-button active flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-credit-card ml-2"></i>پرداخت‌ها
                    </button>
                    <button onclick="showTab('charges')" id="chargesTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-wallet ml-2"></i>شارژ کیف پول
                    </button>
                    <button onclick="showTab('orders')" id="ordersTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-list ml-2"></i>سفارش‌ها
                    </button>
                    <button onclick="showTab('tickets')" id="ticketsTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-ticket-alt ml-2"></i>تیکت‌ها
                    </button>
                    <button onclick="showTab('plans')" id="plansTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-clipboard-list ml-2"></i>پلن‌ها
                    </button>
                    <button onclick="showTab('servers')" id="serversTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-server ml-2"></i>سرورها
                    </button>
                    <button onclick="showTab('users')" id="usersTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-users ml-2"></i>کاربران
                    </button>
                    <button onclick="showTab('settings')" id="settingsTab" class="tab-button flex-shrink-0 w-auto py-4 px-4 text-center border-b-2 font-medium text-sm">
                        <i class="fas fa-cog ml-2"></i>تنظیمات
                    </button>
                </nav>
            </div>

            <!-- Payments Tab -->
            <div id="paymentsContent" class="tab-content p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">پرداخت‌های در انتظار تأیید</h2>
                    <button onclick="refreshPayments()" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt ml-2"></i>بروزرسانی
                    </button>
                </div>
                <div id="pendingPaymentsList" class="space-y-4">
                    <!-- Pending payments will be loaded here -->
                </div>
            </div>

            <!-- Charges Tab -->
            <div id="chargesContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">شارژ کیف پول در انتظار تأیید</h2>
                    <button onclick="refreshCharges()" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt ml-2"></i>بروزرسانی
                    </button>
                </div>
                <div id="pendingChargesList" class="space-y-4">
                    <!-- Pending charges will be loaded here -->
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="ordersContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">تمام سفارش‌ها</h2>
                    <button onclick="loadOrders()" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt ml-2"></i>بروزرسانی
                    </button>
                </div>
                <div id="ordersList" class="space-y-4">
                    <!-- Orders will be loaded here -->
                </div>
            </div>

            <!-- Tickets Tab -->
            <div id="ticketsContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">مدیریت تیکت‌ها</h2>
                    <button onclick="loadTickets()" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt ml-2"></i>بروزرسانی
                    </button>
                </div>
                <div id="ticketsList" class="space-y-4">
                    <!-- Tickets will be loaded here -->
                </div>
            </div>

            <!-- Plans Management Tab -->
            <div id="plansContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">مدیریت پلن‌ها</h2>
                    <button onclick="showAddPlanModal()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 transition-colors">
                        <i class="fas fa-plus ml-2"></i>افزودن پلن
                    </button>
                </div>
                <div id="plansList" class="space-y-4">
                    <!-- Plans will be loaded here -->
                </div>
            </div>

            <!-- Servers Management Tab -->
            <div id="serversContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">مدیریت سرورها</h2>
                    <button onclick="showAddServerModal()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 transition-colors">
                        <i class="fas fa-plus ml-2"></i>افزودن سرور
                    </button>
                </div>
                <div id="serversList" class="space-y-4">
                    <!-- Servers will be loaded here -->
                </div>
            </div>

            <!-- Users Tab -->
            <div id="usersContent" class="tab-content p-6 hidden">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">کاربران سیستم</h2>
                    <button onclick="loadUsers()" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt ml-2"></i>بروزرسانی
                    </button>
                </div>
                <div id="usersList" class="space-y-4">
                    <!-- Users will be loaded here -->
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settingsContent" class="tab-content p-6 hidden">
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-6">تنظیمات سیستم</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                        <h3 class="font-semibold mb-4">تنظیمات پرداخت</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium mb-1">شماره کارت:</label>
                                <input type="text" value="${PAYMENT_INFO.cardNumber}" readonly class="w-full p-2 border rounded-lg bg-gray-100 dark:bg-gray-600">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-1">نام دارنده:</label>
                                <input type="text" value="${PAYMENT_INFO.cardHolder}" readonly class="w-full p-2 border rounded-lg bg-gray-100 dark:bg-gray-600">
                            </div>
                        </div>
                    </div>
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                        <h3 class="font-semibold mb-4">اینباند کاربر مرجع</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium mb-1">نام کاربری مرجع:</label>
                                <input type="text" id="referenceUsername" placeholder="برای تنظیم اینباندها" class="w-full p-2 border rounded-lg">
                            </div>
                            <button onclick="saveInboundSettings()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                                <i class="fas fa-save ml-2"></i>ذخیره تنظیمات
                            </button>
                            <div class="text-sm text-gray-600 dark:text-gray-400">
                                در صورت تنظیم، اینباندهای کاربران جدید از این کاربر کپی می‌شود
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Plan Modal -->
    <div id="addPlanModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold mb-4">افزودن پلن جدید</h3>
            <form id="addPlanForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">نام پلن:</label>
                    <input type="text" id="planName" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">قیمت (تومان):</label>
                    <input type="number" id="planPrice" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">مدت اعتبار (روز):</label>
                    <input type="number" id="planDuration" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">حجم ترافیک (گیگابایت) - 0 برای نامحدود:</label>
                    <input type="number" id="planDataLimit" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">توضیحات:</label>
                    <textarea id="planDescription" rows="3" class="w-full p-2 border rounded-lg"></textarea>
                </div>
                <div class="flex space-x-2 space-x-reverse">
                    <button type="submit" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        <i class="fas fa-save ml-2"></i>ذخیره
                    </button>
                    <button type="button" onclick="hideModal('addPlanModal')" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                        انصراف
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Plan Modal -->
    <div id="editPlanModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold mb-4">ویرایش پلن</h3>
            <form id="editPlanForm" class="space-y-4">
                <input type="hidden" id="editPlanId">
                <div>
                    <label class="block text-sm font-medium mb-1">نام پلن:</label>
                    <input type="text" id="editPlanName" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">قیمت (تومان):</label>
                    <input type="number" id="editPlanPrice" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">مدت اعتبار (روز):</label>
                    <input type="number" id="editPlanDuration" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">حجم ترافیک (گیگابایت) - 0 برای نامحدود:</label>
                    <input type="number" id="editPlanDataLimit" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">توضیحات:</label>
                    <textarea id="editPlanDescription" rows="3" class="w-full p-2 border rounded-lg"></textarea>
                </div>
                <div class="flex space-x-2 space-x-reverse">
                    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        <i class="fas fa-save ml-2"></i>ذخیره تغییرات
                    </button>
                    <button type="button" onclick="hideModal('editPlanModal')" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                        انصراف
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Server Modal -->
    <div id="addServerModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold mb-4">افزودن سرور جدید</h3>
            <form id="addServerForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">نام سرور:</label>
                    <input type="text" id="serverName" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">آدرس پایه:</label>
                    <input type="url" id="serverBaseUrl" required placeholder="https://example.com:2053" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">نام کاربری مرزبان:</label>
                    <input type="text" id="serverUsername" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">رمز عبور مرزبان:</label>
                    <input type="password" id="serverPassword" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">موقعیت:</label>
                    <input type="text" id="serverLocation" required class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">توضیحات:</label>
                    <textarea id="serverDescription" rows="3" class="w-full p-2 border rounded-lg"></textarea>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="serverIsDefault" class="ml-2">
                    <label for="serverIsDefault" class="text-sm">سرور پیش‌فرض</label>
                </div>
                <div class="flex space-x-2 space-x-reverse">
                    <button type="submit" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        <i class="fas fa-save ml-2"></i>ذخیره
                    </button>
                    <button type="button" onclick="hideModal('addServerModal')" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                        انصراف
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Ticket Details Modal -->
    <div id="ticketDetailsModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold mb-4">جزئیات تیکت</h3>
            <div id="ticketDetailsContent">
                <!-- Ticket details will be loaded here -->
            </div>
            <div class="flex space-x-2 space-x-reverse mt-4">
                <button onclick="hideModal('ticketDetailsModal')" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                    بستن
                </button>
            </div>
        </div>
    </div>

    <script>
        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadStats();
            showTab('payments');
        });

        // Tab functionality
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'Content').classList.remove('hidden');
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'payments') {
                refreshPayments();
            } else if (tabName === 'charges') {
                refreshCharges();
            } else if (tabName === 'orders') {
                loadOrders();
            } else if (tabName === 'tickets') {
                loadTickets();
            } else if (tabName === 'plans') {
                loadPlans();
            } else if (tabName === 'servers') {
                loadServers();
            } else if (tabName === 'users') {
                loadUsers();
            } else if (tabName === 'settings') {
                loadSettings();
            }
        }

        // Modal functions
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        function showAddPlanModal() {
            document.getElementById('addPlanForm').reset();
            showModal('addPlanModal');
        }

        function showEditPlanModal(plan) {
            document.getElementById('editPlanId').value = plan.id;
            document.getElementById('editPlanName').value = plan.name;
            document.getElementById('editPlanPrice').value = plan.price;
            document.getElementById('editPlanDuration').value = plan.duration;
            document.getElementById('editPlanDataLimit').value = plan.dataLimit;
            document.getElementById('editPlanDescription').value = plan.description || '';
            showModal('editPlanModal');
        }

        function showAddServerModal() {
            document.getElementById('addServerForm').reset();
            showModal('addServerModal');
        }

        // API functions
        async function apiCall(endpoint, method = 'GET', data = null) {
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'X-Admin-Auth': '${ADMIN_PASSWORD}'
                }
            };
            
            if (data) {
                options.body = JSON.stringify(data);
            }
            
            const response = await fetch(endpoint, options);
            return await response.json();
        }

        // Load stats
        async function loadStats() {
            try {
                const stats = await apiCall('/api/admin/stats');
                if (stats.success) {
                    document.getElementById('todayOrders').textContent = stats.data.todayOrders;
                    document.getElementById('todayRevenue').textContent = stats.data.todayRevenue.toLocaleString() + ' تومان';
                    document.getElementById('pendingPayments').textContent = stats.data.pendingPayments;
                    document.getElementById('pendingCharges').textContent = stats.data.pendingCharges || 0;
                    document.getElementById('openTickets').textContent = stats.data.openTickets;
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Load pending payments
        async function refreshPayments() {
            try {
                const data = await apiCall('/api/admin/pending-payments');
                const container = document.getElementById('pendingPaymentsList');
                
                if (data.payments && data.payments.length > 0) {
                    container.innerHTML = data.payments.map(payment => \`
                        <div class="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="font-semibold text-lg">\${payment.plan.name}</h3>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">سفارش: \${payment.id}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">کاربر: <span class="font-mono">\${payment.chatId}</span></p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">مبلغ: \${payment.plan.price.toLocaleString()} تومان</p>
                                    \${payment.type === 'renewal' ? \`<p class="text-sm text-gray-600 dark:text-gray-400">نوع: تمدید سرویس</p>\` : \`<p class="text-sm text-gray-600 dark:text-gray-400">سرور: \${payment.serverName}</p>\`}
                                    <p class="text-sm text-gray-600 dark:text-gray-400">زمان: \${new Date(payment.paymentSubmittedAt).toLocaleString('fa-IR')}</p>
                                </div>
                                <div class="flex space-x-2 space-x-reverse">
                                    <button onclick="approvePayment('\${payment.id}')" class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600">
                                        ✅ تأیید
                                    </button>
                                    <button onclick="rejectPayment('\${payment.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                        ❌ رد
                                    </button>
                                </div>
                            </div>
                        </div>
                    \`).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">پرداخت در انتظاری وجود ندارد</div>';
                }
            } catch (error) {
                console.error('Error loading payments:', error);
            }
        }

        // Load pending charges
        async function refreshCharges() {
            try {
                const data = await apiCall('/api/admin/pending-charges');
                const container = document.getElementById('pendingChargesList');
                
                if (data.charges && data.charges.length > 0) {
                    container.innerHTML = data.charges.map(charge => \`
                        <div class="bg-orange-50 dark:bg-orange-900/20 border border-orange-200 dark:border-orange-800 rounded-lg p-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="font-semibold text-lg">شارژ کیف پول</h3>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">شارژ: \${charge.id}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">کاربر: <span class="font-mono">\${charge.chatId}</span></p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">مبلغ: \${charge.amount.toLocaleString()} تومان</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">زمان: \${new Date(charge.paymentSubmittedAt).toLocaleString('fa-IR')}</p>
                                </div>
                                <div class="flex space-x-2 space-x-reverse">
                                    <button onclick="approveCharge('\${charge.id}')" class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600">
                                        ✅ تأیید
                                    </button>
                                    <button onclick="rejectCharge('\${charge.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                        ❌ رد
                                    </button>
                                </div>
                            </div>
                        </div>
                    \`).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">شارژ در انتظاری وجود ندارد</div>';
                }
            } catch (error) {
                console.error('Error loading charges:', error);
            }
        }

        // Load all orders
        async function loadOrders() {
            try {
                const data = await apiCall('/api/admin/orders');
                const container = document.getElementById('ordersList');
                
                if (data.orders && data.orders.length > 0) {
                    container.innerHTML = data.orders.map(order => {
                        const statusColors = {
                            'completed': 'bg-green-50 border-green-200 text-green-800',
                            'payment_submitted': 'bg-yellow-50 border-yellow-200 text-yellow-800',
                            'waiting_payment': 'bg-blue-50 border-blue-200 text-blue-800',
                            'rejected': 'bg-red-50 border-red-200 text-red-800'
                        };
                        const statusTexts = {
                            'completed': 'تکمیل شده',
                            'payment_submitted': 'در انتظار تأیید',
                            'waiting_payment': 'در انتظار پرداخت', 
                            'rejected': 'رد شده'
                        };
                        const statusClass = statusColors[order.status] || 'bg-gray-50 border-gray-200 text-gray-800';
                        const statusText = statusTexts[order.status] || order.status;
                        
                        return \`
                            <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                                <div class="flex justify-between items-start">
                                    <div>
                                        <h3 class="font-semibold text-lg">\${order.plan.name}</h3>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">سفارش: \${order.id}</p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">کاربر: <span class="font-mono">\${order.chatId}</span></p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">مبلغ: \${order.plan.price.toLocaleString()} تومان</p>
                                        \${order.paymentMethod ? \`<p class="text-sm text-gray-600 dark:text-gray-400">روش پرداخت: \${order.paymentMethod === 'wallet' ? 'کیف پول' : 'کارت به کارت'}</p>\` : ''}
                                        \${order.type === 'renewal' ? \`<p class="text-sm text-gray-600 dark:text-gray-400">نوع: تمدید سرویس</p>\` : ''}
                                        <p class="text-sm text-gray-600 dark:text-gray-400">تاریخ: \${new Date(order.createdAt).toLocaleString('fa-IR')}</p>
                                    </div>
                                    <div>
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium \${statusClass}">
                                            \${statusText}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        \`;
                    }).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">سفارشی یافت نشد</div>';
                }
            } catch (error) {
                console.error('Error loading orders:', error);
            }
        }

        // Load tickets
        async function loadTickets() {
            try {
                const data = await apiCall('/api/admin/tickets');
                const container = document.getElementById('ticketsList');
                
                if (data.tickets && data.tickets.length > 0) {
                    container.innerHTML = data.tickets.map(ticket => {
                        const statusEmoji = ticket.status === 'open' ? '🟢' : '🔴';
                        const statusText = ticket.status === 'open' ? 'باز' : 'بسته';
                        
                        return \`
                            <div class="bg-white dark:bg-gray-700 rounded-lg p-4 border">
                                <div class="flex justify-between items-start">
                                    <div>
                                        <h3 class="font-semibold text-lg">\${ticket.typeName}</h3>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">تیکت: \${ticket.id}</p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">کاربر: <span class="font-mono">\${ticket.chatId}</span></p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">موضوع: \${ticket.subject}</p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">تاریخ: \${new Date(ticket.createdAt).toLocaleString('fa-IR')}</p>
                                        <p class="text-sm text-gray-600 dark:text-gray-400">وضعیت: \${statusEmoji} \${statusText}</p>
                                    </div>
                                    <div class="flex space-x-2 space-x-reverse">
                                        <button onclick="viewTicketDetails('\${ticket.id}')" class="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600">
                                            👁️ مشاهده
                                        </button>
                                        \${ticket.status === 'open' ? \`<button onclick="closeTicket('\${ticket.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                            🔒 بستن
                                        </button>\` : ''}
                                    </div>
                                </div>
                            </div>
                        \`;
                    }).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">تیکتی یافت نشد</div>';
                }
            } catch (error) {
                console.error('Error loading tickets:', error);
            }
        }

        // View ticket details
        async function viewTicketDetails(ticketId) {
            try {
                const data = await apiCall('/api/admin/tickets/' + ticketId);
                if (data.ticket) {
                    const ticket = data.ticket;
                    const statusEmoji = ticket.status === 'open' ? '🟢' : '🔴';
                    const statusText = ticket.status === 'open' ? 'باز' : 'بسته';
                    
                    let messagesHtml = '';
                    ticket.messages.forEach(msg => {
                        const fromEmoji = msg.from === 'user' ? '👤' : '👨‍💼';
                        const fromText = msg.from === 'user' ? 'کاربر' : 'پشتیبانی';
                        const time = new Date(msg.timestamp).toLocaleString('fa-IR');
                        
                        messagesHtml += \`
                            <div class="mb-4 p-3 \${msg.from === 'user' ? 'bg-blue-50' : 'bg-green-50'} rounded">
                                <div class="font-semibold">\${fromEmoji} \${fromText} - \${time}</div>
                                <div class="mt-2">\${msg.message}</div>
                            </div>
                        \`;
                    });
                    
                    document.getElementById('ticketDetailsContent').innerHTML = \`
                        <div>
                            <h4 class="font-semibold mb-2">اطلاعات تیکت</h4>
                            <p><strong>شماره:</strong> \${ticket.id}</p>
                            <p><strong>کاربر:</strong> <span class="font-mono">\${ticket.chatId}</span></p>
                            <p><strong>موضوع:</strong> \${ticket.typeName}</p>
                            <p><strong>تاریخ:</strong> \${new Date(ticket.createdAt).toLocaleString('fa-IR')}</p>
                            <p><strong>وضعیت:</strong> \${statusEmoji} \${statusText}</p>
                            
                            <h4 class="font-semibold mt-4 mb-2">پیام‌ها</h4>
                            \${messagesHtml}
                        </div>
                    \`;
                    
                    showModal('ticketDetailsModal');
                }
            } catch (error) {
                console.error('Error loading ticket details:', error);
                alert('خطا در بارگیری جزئیات تیکت');
            }
        }

        // Close ticket
        async function closeTicket(ticketId) {
            if (confirm('آیا از بستن این تیکت اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/tickets/' + ticketId + '/close', 'POST');
                    if (result.success) {
                        alert('تیکت بسته شد!');
                        loadTickets();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در بستن تیکت');
                }
            }
        }

        // Load plans
        async function loadPlans() {
            try {
                const data = await apiCall('/api/admin/plans');
                const container = document.getElementById('plansList');
                
                if (data.plans && Object.keys(data.plans).length > 0) {
                    container.innerHTML = Object.values(data.plans).map(plan => \`
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="font-semibold text-lg">\${plan.name}</h3>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">قیمت: \${plan.price.toLocaleString()} تومان</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">مدت: \${plan.duration} روز</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">حجم: \${plan.dataLimit ? plan.dataLimit + ' گیگابایت' : 'نامحدود'}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">توضیحات: \${plan.description}</p>
                                </div>
                                <div class="flex space-x-2 space-x-reverse">
                                    <button onclick="showEditPlanModal(\${JSON.stringify(plan).replace(/"/g, '&quot;')})" class="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600">
                                        <i class="fas fa-edit"></i> ویرایش
                                    </button>
                                    <button onclick="deletePlan('\${plan.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                        <i class="fas fa-trash"></i> حذف
                                    </button>
                                </div>
                            </div>
                        </div>
                    \`).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">پلنی تعریف نشده است</div>';
                }
            } catch (error) {
                console.error('Error loading plans:', error);
            }
        }

        // Load servers
        async function loadServers() {
            try {
                const data = await apiCall('/api/admin/servers');
                const container = document.getElementById('serversList');
                
                if (data.servers && Object.keys(data.servers).length > 0) {
                    container.innerHTML = Object.values(data.servers).map(server => \`
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="font-semibold text-lg">\${server.name} \${server.isDefault ? '<span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">پیش‌فرض</span>' : ''}</h3>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">آدرس: \${server.baseUrl}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">موقعیت: \${server.location}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">وضعیت: \${server.status === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">توضیحات: \${server.description}</p>
                                </div>
                                <div class="flex space-x-2 space-x-reverse">
                                    <button onclick="testServer('\${server.id}')" class="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600">
                                        <i class="fas fa-check"></i> تست
                                    </button>
                                    \${!server.isDefault ? \`<button onclick="deleteServer('\${server.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                        <i class="fas fa-trash"></i> حذف
                                    </button>\` : ''}
                                </div>
                            </div>
                        </div>
                    \`).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">سروری تعریف نشده است</div>';
                }
            } catch (error) {
                console.error('Error loading servers:', error);
            }
        }

        // Load users
        async function loadUsers() {
            try {
                const data = await apiCall('/api/admin/users');
                const container = document.getElementById('usersList');
                
                if (data.users && data.users.length > 0) {
                    container.innerHTML = data.users.map(user => \`
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="font-semibold text-lg">کاربر: <span class="font-mono">\${user.chatId}</span></h3>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">تعداد سرویس‌ها: \${user.servicesCount}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">تعداد سفارش‌ها: \${user.ordersCount}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">تعداد تیکت‌ها: \${user.ticketsCount}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">موجودی کیف پول: \${user.walletBalance ? user.walletBalance.toLocaleString() + ' تومان' : '0 تومان'}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">آخرین فعالیت: \${user.lastActivity ? new Date(user.lastActivity).toLocaleString('fa-IR') : 'نامشخص'}</p>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">کل پرداخت‌ها: \${user.totalPayments.toLocaleString()} تومان</p>
                                </div>
                                <div class="flex flex-col space-y-2">
                                    <span class="text-xs px-2 py-1 rounded \${user.servicesCount > 0 ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'}">
                                        \${user.servicesCount > 0 ? 'فعال' : 'غیرفعال'}
                                    </span>
                                </div>
                            </div>
                        </div>
                    \`).join('');
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-500">کاربری یافت نشد</div>';
                }
            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        // Load settings
        async function loadSettings() {
            try {
                const data = await apiCall('/api/admin/inbound-settings');
                if (data.settings && data.settings.referenceUsername) {
                    document.getElementById('referenceUsername').value = data.settings.referenceUsername;
                }
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        // Save inbound settings
        async function saveInboundSettings() {
            try {
                const referenceUsername = document.getElementById('referenceUsername').value;
                const result = await apiCall('/api/admin/inbound-settings', 'POST', { referenceUsername });
                if (result.success) {
                    alert('تنظیمات اینباند ذخیره شد!');
                } else {
                    alert('خطا: ' + result.error);
                }
            } catch (error) {
                alert('خطا در ذخیره تنظیمات');
            }
        }

        // Add plan
        document.getElementById('addPlanForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const planData = {
                name: document.getElementById('planName').value,
                price: parseInt(document.getElementById('planPrice').value),
                duration: parseInt(document.getElementById('planDuration').value),
                dataLimit: parseInt(document.getElementById('planDataLimit').value),
                description: document.getElementById('planDescription').value
            };
            
            try {
                const result = await apiCall('/api/admin/plans', 'POST', planData);
                if (result.success) {
                    alert('پلن با موفقیت اضافه شد!');
                    hideModal('addPlanModal');
                    loadPlans();
                } else {
                    alert('خطا: ' + result.error);
                }
            } catch (error) {
                alert('خطا در افزودن پلن');
            }
        });

        // Edit plan
        document.getElementById('editPlanForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const planId = document.getElementById('editPlanId').value;
            const planData = {
                name: document.getElementById('editPlanName').value,
                price: parseInt(document.getElementById('editPlanPrice').value),
                duration: parseInt(document.getElementById('editPlanDuration').value),
                dataLimit: parseInt(document.getElementById('editPlanDataLimit').value),
                description: document.getElementById('editPlanDescription').value
            };
            
            try {
                const result = await apiCall('/api/admin/plans/' + planId, 'PUT', planData);
                if (result.success) {
                    alert('پلن با موفقیت ویرایش شد!');
                    hideModal('editPlanModal');
                    loadPlans();
                } else {
                    alert('خطا: ' + result.error);
                }
            } catch (error) {
                alert('خطا در ویرایش پلن');
            }
        });

        // Add server
        document.getElementById('addServerForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const serverData = {
                name: document.getElementById('serverName').value,
                baseUrl: document.getElementById('serverBaseUrl').value,
                username: document.getElementById('serverUsername').value,
                password: document.getElementById('serverPassword').value,
                location: document.getElementById('serverLocation').value,
                description: document.getElementById('serverDescription').value,
                isDefault: document.getElementById('serverIsDefault').checked
            };
            
            try {
                const result = await apiCall('/api/admin/servers', 'POST', serverData);
                if (result.success) {
                    alert('سرور با موفقیت اضافه شد!');
                    hideModal('addServerModal');
                    loadServers();
                } else {
                    alert('خطا: ' + result.error);
                }
            } catch (error) {
                alert('خطا در افزودن سرور');
            }
        });

        // Delete plan
        async function deletePlan(planId) {
            if (confirm('آیا از حذف این پلن اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/plans/' + planId, 'DELETE');
                    if (result.success) {
                        alert('پلن حذف شد!');
                        loadPlans();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در حذف پلن');
                }
            }
        }

        // Delete server
        async function deleteServer(serverId) {
            if (confirm('آیا از حذف این سرور اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/servers/' + serverId, 'DELETE');
                    if (result.success) {
                        alert('سرور حذف شد!');
                        loadServers();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در حذف سرور');
                }
            }
        }

        // Test server
        async function testServer(serverId) {
            try {
                const result = await apiCall('/api/admin/servers/' + serverId + '/test');
                if (result.success) {
                    alert('سرور به درستی کار می‌کند! ✅');
                } else {
                    alert('خطا در اتصال به سرور: ' + result.error);
                }
            } catch (error) {
                alert('خطا در تست سرور');
            }
        }

        // Approve payment
        async function approvePayment(orderId) {
            if (confirm('آیا از تأیید این پرداخت اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/approve-payment', 'POST', { orderId });
                    if (result.success) {
                        alert('پرداخت تأیید شد!');
                        refreshPayments();
                        loadStats();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در تأیید پرداخت');
                }
            }
        }

        // Reject payment
        async function rejectPayment(orderId) {
            if (confirm('آیا از رد این پرداخت اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/reject-payment', 'POST', { orderId });
                    if (result.success) {
                        alert('پرداخت رد شد!');
                        refreshPayments();
                        loadStats();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در رد پرداخت');
                }
            }
        }

        // Approve charge
        async function approveCharge(chargeId) {
            if (confirm('آیا از تأیید این شارژ اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/approve-charge', 'POST', { chargeId });
                    if (result.success) {
                        alert('شارژ تأیید شد!');
                        refreshCharges();
                        loadStats();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در تأیید شارژ');
                }
            }
        }

        // Reject charge
        async function rejectCharge(chargeId) {
            if (confirm('آیا از رد این شارژ اطمینان دارید؟')) {
                try {
                    const result = await apiCall('/api/admin/reject-charge', 'POST', { chargeId });
                    if (result.success) {
                        alert('شارژ رد شد!');
                        refreshCharges();
                        loadStats();
                    } else {
                        alert('خطا: ' + result.error);
                    }
                } catch (error) {
                    alert('خطا در رد شارژ');
                }
            }
        }

        // Logout
        function logout() {
            if (confirm('آیا می‌خواهید خروج کنید؟')) {
                window.location.href = '/admin?logout=1';
            }
        }
    </script>
</body>
</html>`;
}

// تابع لاگین ادمین
function getAdminLogin() {
  return `<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ورود به پنل مدیریت</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100;200;300;400;500;600;700;800;900&display=swap');
        * { 
            font-family: 'Vazirmatn', 'Tahoma', Arial, sans-serif !important;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-500 to-purple-600 min-h-screen flex items-center justify-center">
    <div class="bg-white rounded-lg shadow-xl p-8 w-full max-w-md">
        <div class="text-center mb-8">
            <i class="fas fa-shield-alt text-4xl text-blue-600 mb-4"></i>
            <h1 class="text-2xl font-bold text-gray-900">پنل مدیریت ARDISK VPN</h1>
            <p class="text-gray-600 mt-2">برای ورود رمز عبور را وارد کنید</p>
        </div>
        
        <form onsubmit="handleLogin(event)" class="space-y-6">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">رمز عبور مدیریت</label>
                <input type="password" id="password" required
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                       placeholder="رمز عبور را وارد کنید">
            </div>
            
            <button type="submit" 
                    class="w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
                <i class="fas fa-sign-in-alt ml-2"></i>
                ورود به پنل
            </button>
        </form>
        
        <div id="error" class="mt-4 text-red-600 text-sm text-center hidden"></div>
    </div>

    <script>
        function handleLogin(event) {
            event.preventDefault();
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('error');
            
            if (password === '${ADMIN_PASSWORD}') {
                // Set session and redirect
                document.cookie = 'admin_session=${ADMIN_PASSWORD}; path=/; max-age=3600';
                window.location.href = '/admin';
            } else {
                errorDiv.textContent = 'رمز عبور اشتباه است!';
                errorDiv.classList.remove('hidden');
                setTimeout(() => {
                    errorDiv.classList.add('hidden');
                }, 3000);
            }
        }
    </script>
</body>
</html>`;
}

// تست سیستم VPN و Cron Job
async function testVPNSystem(chatId, kv) {
  try {
    const testMessage = await sendMessage(chatId, '🔄 <b>شروع تست سیستم VPN...</b>\n\n⏳ در حال بررسی...');
    const testMessageId = testMessage.result.message_id;
    
    let testResults = [];
    
    // 1. تست کلی سیستم
    testResults.push('🧪 <b>تست سیستم ARDISK VPN</b>\n');
    
    // 2. تست دسترسی به KV
    try {
      await kv.get('test_key');
      testResults.push('✅ KV Database: متصل');
    } catch (error) {
      testResults.push('❌ KV Database: خطا - ' + error.message);
    }
    
    // 3. تست سرویس‌ها
    const servicesResult = await kv.list('service_');
    testResults.push(`📱 تعداد سرویس‌ها: ${servicesResult.keys.length} عدد`);
    
    let activeServices = 0;
    let expiredServices = 0;
    let nearExpiryServices = 0;
    let trafficWarningServices = 0;
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    
    for (const key of servicesResult.keys.slice(0, 50)) {
      try {
        const service = await kv.get(key.name, 'json');
        if (service) {
          const timeUntilExpiry = service.expireTimestamp - now;
          const daysUntilExpiry = Math.ceil(timeUntilExpiry / oneDayMs);
          
          if (service.status === 'active') {
            activeServices++;
            if (daysUntilExpiry <= 1 && daysUntilExpiry > 0) {
              nearExpiryServices++;
            }
          } else {
            expiredServices++;
          }
          
          // چک ترافیک برای سرویس‌های محدود
          if (service.dataLimit && service.dataLimit > 0) {
            trafficWarningServices++;
          }
        }
      } catch (e) {}
    }
    
    testResults.push(`🟢 سرویس‌های فعال: ${activeServices}`);
    testResults.push(`🔴 سرویس‌های منقضی: ${expiredServices}`);
    testResults.push(`⚠️ نزدیک به انقضا: ${nearExpiryServices}`);
    testResults.push(`📊 دارای محدودیت حجم: ${trafficWarningServices}`);
    
    // 4. تست سرورها
    const servers = await getServers(kv);
    testResults.push(`\n🖥️ <b>تست سرورها:</b>`);
    testResults.push(`📊 تعداد سرورها: ${Object.keys(servers).length} عدد`);
    
    let connectedServers = 0;
    let failedServers = 0;
    
    for (const [serverId, server] of Object.entries(servers)) {
      try {
        const api = new MarzbanAPI(server.baseUrl);
        const loginResult = await api.login(server.username, server.password);
        
        if (loginResult.success) {
          connectedServers++;
          testResults.push(`✅ ${server.name}: متصل`);
        } else {
          failedServers++;
          testResults.push(`❌ ${server.name}: ${loginResult.error}`);
        }
      } catch (error) {
        failedServers++;
        testResults.push(`❌ ${server.name}: خطا اتصال`);
      }
    }
    
    // 5. تست Cron Job شبیه‌سازی
    testResults.push(`\n⏰ <b>تست Cron Job:</b>`);
    try {
      const cronTestStart = Date.now();
      await checkExpiringServices(kv);
      const cronTestEnd = Date.now();
      const cronDuration = cronTestEnd - cronTestStart;
      testResults.push(`✅ Cron Job: اجرا شد (${cronDuration}ms)`);
    } catch (error) {
      testResults.push(`❌ Cron Job: خطا - ${error.message}`);
    }
    
    // 6. تست اطلاع‌رسانی
    testResults.push(`\n📢 <b>تست اطلاع‌رسانی:</b>`);
    const notificationsResult = await kv.list('notification_');
    testResults.push(`📊 تعداد notification ها: ${notificationsResult.keys.length}`);
    
    // 7. آمار پایگاه داده
    const ordersResult = await kv.list('order_ORD_');
    const ticketsResult = await kv.list('ticket_');
    const chargesResult = await kv.list('wallet_charge_');
    
    testResults.push(`\n📊 <b>آمار پایگاه داده:</b>`);
    testResults.push(`🛒 سفارش‌ها: ${ordersResult.keys.length}`);
    testResults.push(`🎫 تیکت‌ها: ${ticketsResult.keys.length}`);
    testResults.push(`💰 شارژها: ${chargesResult.keys.length}`);
    
    // 8. خلاصه نتایج
    testResults.push(`\n🎯 <b>خلاصه تست:</b>`);
    testResults.push(`✅ سرورهای متصل: ${connectedServers}/${Object.keys(servers).length}`);
    testResults.push(`📱 سرویس‌های فعال: ${activeServices}`);
    testResults.push(`⚠️ نیاز به توجه: ${nearExpiryServices + failedServers}`);
    
    // 9. وضعیت کلی سیستم
    const systemHealth = (connectedServers === Object.keys(servers).length && failedServers === 0) ? 
                        '🟢 عالی' : failedServers > 0 ? '🔴 نیاز به بررسی' : '🟡 قابل قبول';
    
    testResults.push(`\n🏥 <b>وضعیت کلی سیستم:</b> ${systemHealth}`);
    testResults.push(`🕐 <b>زمان تست:</b> ${formatDateTime(Date.now())}`);
    
    // ارسال نتایج
    const finalText = testResults.join('\n');
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '🔄 تست مجدد', callback_data: 'admin_retest_system' },
            { text: '📊 آمار تفصیلی', callback_data: 'admin_detailed_stats' }
          ],
          [
            { text: '⚡ اجرای فوری Cron', callback_data: 'admin_force_cron' }
          ],
          [
            { text: '🏠 منوی اصلی', callback_data: 'start' }
          ]
        ]
      }
    };
    
    await editMessage(chatId, testMessageId, finalText, keyboard);
    
  } catch (error) {
    console.error('Error in system test:', error);
    await sendMessage(chatId, `❌ <b>خطا در تست سیستم:</b>\n\n${error.message}`);
  }
}

// تست اطلاع‌رسانی فوری
async function testNotificationSystem(chatId, kv) {
  try {
    const testText = `🧪 <b>تست اطلاع‌رسانی</b>

این یک تست اطلاع‌رسانی سیستم است.

⏰ زمان: ${formatDateTime(Date.now())}
🤖 وضعیت: ربات فعال است
📡 ارتباط: برقرار
💾 پایگاه داده: متصل

✅ تست موفقیت‌آمیز!`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '✅ تست دریافت شد', callback_data: 'test_received' }]
        ]
      }
    };

    await sendMessage(chatId, testText, keyboard);
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// اجرای فوری Cron Job
async function forceRunCronJob(chatId, messageId, kv) {
  try {
    await editMessage(chatId, messageId, '⏳ <b>اجرای فوری Cron Job...</b>\n\nلطفاً صبر کنید...');
    
    const startTime = Date.now();
    await checkExpiringServices(kv);
    const endTime = Date.now();
    
    const duration = endTime - startTime;
    
    const successText = `✅ <b>Cron Job با موفقیت اجرا شد!</b>

⏱️ مدت زمان اجرا: ${duration}ms
🕐 زمان اجرا: ${formatDateTime(Date.now())}

📊 Cron Job شامل موارد زیر بررسی شد:
• انقضای سرویس‌ها
• مصرف ترافیک
• ارسال اطلاع‌رسانی‌ها

✅ همه چیز به درستی کار می‌کند!`;

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔄 اجرای مجدد', callback_data: 'admin_force_cron' }],
          [{ text: '🧪 تست کامل سیستم', callback_data: 'admin_full_test' }],
          [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
        ]
      }
    };

    await editMessage(chatId, messageId, successText, keyboard);
    
  } catch (error) {
    console.error('Error in force cron job:', error);
    await editMessage(chatId, messageId, 
      `❌ <b>خطا در اجرای Cron Job:</b>\n\n${error.message}`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🔄 تلاش مجدد', callback_data: 'admin_force_cron' }],
            [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
          ]
        }
      }
    );
  }
}

// تابع جدید برای پاک کردن تمام وضعیت‌های در انتظار کاربر
async function clearUserPendingState(chatId, kv) {
  try {
    // لیستی از کلیدهای وضعیتی که باید پاک شوند
    const pendingKeys = [
      `pending_ticket_${chatId}`,
      `pending_user_reply_${chatId}`,
      `waiting_charge_amount_${chatId}`,
      `user_charge_${chatId}`,
      `user_order_${chatId}`,
      `selected_plan_${chatId}`,
      `renewal_plan_${chatId}`,
      `waiting_username_${chatId}`,
      // برای ادمین
      `pending_reply_${chatId}`
    ];

    // حذف همه کلیدها به صورت موازی برای سرعت بیشتر
    const deletionPromises = pendingKeys.map(key => kv.delete(key));
    await Promise.all(deletionPromises);
    
    console.log(`Cleared all pending states for user ${chatId}`);
    return true;
  } catch (error) {
    console.error(`Error clearing pending state for user ${chatId}:`, error);
    return false;
  }
}

// Worker اصلی
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // پنل مدیریت وب
    if (url.pathname.startsWith('/admin')) {
      if (request.method === 'GET') {
        // بررسی لاگ اوت
        if (url.searchParams.get('logout')) {
          return new Response('', {
            status: 302,
            headers: {
              'Location': '/admin',
              'Set-Cookie': 'admin_session=; path=/; max-age=0'
            }
          });
        }

        // بررسی احراز هویت
        const cookies = request.headers.get('Cookie') || '';
        const isAuthenticated = cookies.includes(`admin_session=${ADMIN_PASSWORD}`);

        if (!isAuthenticated) {
          return new Response(getAdminLogin(), {
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        }

        return new Response(getAdminWebPanel(), {
          headers: { 'Content-Type': 'text/html; charset=utf-8' }
        });
      }
    }

    // Cron job برای بررسی انقضای سرویس‌ها
    if (url.pathname === '/cron/check-expiry') {
      const safeKV = new SafeKV(env?.KV_B);
      await checkExpiringServices(safeKV);
      return new Response('Expiry check completed', { status: 200 });
    }

    // API endpoints برای پنل ادمین
    if (url.pathname.startsWith('/api/admin/')) {
      const authHeader = request.headers.get('X-Admin-Auth');
      if (authHeader !== ADMIN_PASSWORD) {
        return new Response(JSON.stringify({ error: 'Unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      const safeKV = new SafeKV(env?.KV_B);

      // آمار کلی
      if (url.pathname === '/api/admin/stats') {
        try {
          const revenue = await calculateRevenue(safeKV);
          
          // پرداخت‌های در انتظار
          const ordersResult = await safeKV.list('order_ORD_');
          let pendingPayments = 0;
          for (const key of ordersResult.keys) {
            const order = await safeKV.get(key.name, 'json');
            if (order && order.status === 'payment_submitted') {
              pendingPayments++;
            }
          }

          // شارژ کیف پول در انتظار
          const chargesResult = await safeKV.list('wallet_charge_');
          let pendingCharges = 0;
          for (const key of chargesResult.keys) {
            const charge = await safeKV.get(key.name, 'json');
            if (charge && charge.status === 'payment_submitted') {
              pendingCharges++;
            }
          }

          // تیکت‌های باز
          const ticketsResult = await safeKV.list('ticket_');
          let openTickets = 0;
          for (const key of ticketsResult.keys) {
            const ticket = await safeKV.get(key.name, 'json');
            if (ticket && ticket.status === 'open') {
              openTickets++;
            }
          }

          return new Response(JSON.stringify({
            success: true,
            data: {
              todayOrders: revenue.todayOrders,
              todayRevenue: revenue.todayRevenue,
              totalRevenue: revenue.totalRevenue,
              pendingPayments: pendingPayments,
              pendingCharges: pendingCharges,
              openTickets: openTickets
            }
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // پرداخت‌های در انتظار
      if (url.pathname === '/api/admin/pending-payments') {
        try {
          const ordersResult = await safeKV.list('order_ORD_');
          const pendingPayments = [];

          for (const key of ordersResult.keys) {
            const orderData = await safeKV.get(key.name, 'json');
            if (orderData && orderData.status === 'payment_submitted') {
              pendingPayments.push(orderData);
            }
          }

          return new Response(JSON.stringify({ 
            success: true, 
            payments: pendingPayments.sort((a, b) => b.paymentSubmittedAt - a.paymentSubmittedAt)
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // شارژ کیف پول در انتظار
      if (url.pathname === '/api/admin/pending-charges') {
        try {
          const chargesResult = await safeKV.list('wallet_charge_');
          const pendingCharges = [];

          for (const key of chargesResult.keys) {
            const chargeData = await safeKV.get(key.name, 'json');
            if (chargeData && chargeData.status === 'payment_submitted') {
              pendingCharges.push(chargeData);
            }
          }

          return new Response(JSON.stringify({ 
            success: true, 
            charges: pendingCharges.sort((a, b) => b.paymentSubmittedAt - a.paymentSubmittedAt)
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // همه سفارش‌ها
      if (url.pathname === '/api/admin/orders') {
        try {
          const ordersResult = await safeKV.list('order_ORD_');
          const orders = [];

          for (const key of ordersResult.keys) {
            const orderData = await safeKV.get(key.name, 'json');
            if (orderData) {
              orders.push(orderData);
            }
          }

          return new Response(JSON.stringify({ 
            success: true, 
            orders: orders.sort((a, b) => b.createdAt - a.createdAt)
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // تیکت‌ها
      if (url.pathname === '/api/admin/tickets') {
        try {
          const ticketsResult = await safeKV.list('ticket_');
          const tickets = [];

          for (const key of ticketsResult.keys) {
            const ticketData = await safeKV.get(key.name, 'json');
            if (ticketData) {
              tickets.push(ticketData);
            }
          }

          return new Response(JSON.stringify({ 
            success: true, 
            tickets: tickets.sort((a, b) => b.createdAt - a.createdAt)
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // کاربران
      if (url.pathname === '/api/admin/users') {
        try {
          const users = new Map();
          
          // جمع‌آوری اطلاعات از سرویس‌ها
          const servicesResult = await safeKV.list('service_');
          for (const key of servicesResult.keys) {
            const service = await safeKV.get(key.name, 'json');
            if (service && service.chatId) {
              if (!users.has(service.chatId)) {
                users.set(service.chatId, {
                  chatId: service.chatId,
                  servicesCount: 0,
                  ordersCount: 0,
                  ticketsCount: 0,
                  totalPayments: 0,
                  walletBalance: 0,
                  lastActivity: 0
                });
              }
              users.get(service.chatId).servicesCount++;
              users.get(service.chatId).lastActivity = Math.max(
                users.get(service.chatId).lastActivity,
                service.createdAt
              );
            }
          }

          // جمع‌آوری اطلاعات از سفارش‌ها
          const ordersResult = await safeKV.list('order_ORD_');
          for (const key of ordersResult.keys) {
            const order = await safeKV.get(key.name, 'json');
            if (order && order.chatId) {
              if (!users.has(order.chatId)) {
                users.set(order.chatId, {
                  chatId: order.chatId,
                  servicesCount: 0,
                  ordersCount: 0,
                  ticketsCount: 0,
                  totalPayments: 0,
                  walletBalance: 0,
                  lastActivity: 0
                });
              }
              users.get(order.chatId).ordersCount++;
              if (order.status === 'completed') {
                users.get(order.chatId).totalPayments += order.plan.price;
              }
              users.get(order.chatId).lastActivity = Math.max(
                users.get(order.chatId).lastActivity,
                order.createdAt
              );
            }
          }

          // جمع‌آوری اطلاعات از تیکت‌ها
          const ticketsResult = await safeKV.list('ticket_');
          for (const key of ticketsResult.keys) {
            const ticket = await safeKV.get(key.name, 'json');
            if (ticket && ticket.chatId) {
              if (!users.has(ticket.chatId)) {
                users.set(ticket.chatId, {
                  chatId: ticket.chatId,
                  servicesCount: 0,
                  ordersCount: 0,
                  ticketsCount: 0,
                  totalPayments: 0,
                  walletBalance: 0,
                  lastActivity: 0
                });
              }
              users.get(ticket.chatId).ticketsCount++;
              users.get(ticket.chatId).lastActivity = Math.max(
                users.get(ticket.chatId).lastActivity,
                ticket.createdAt
              );
            }
          }

          // جمع‌آوری موجودی کیف پول
          for (const [chatId, user] of users) {
            const balance = await getWalletBalance(chatId, safeKV);
            user.walletBalance = balance;
          }

          const usersList = Array.from(users.values()).sort((a, b) => b.lastActivity - a.lastActivity);

          return new Response(JSON.stringify({ 
            success: true, 
            users: usersList
          }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // جزئیات تیکت
      if (url.pathname.match(/^\/api\/admin\/tickets\/(.+)$/) && request.method === 'GET') {
        try {
          const ticketId = url.pathname.split('/').pop();
          const ticketsResult = await safeKV.list('ticket_');
          
          for (const key of ticketsResult.keys) {
            const ticket = await safeKV.get(key.name, 'json');
            if (ticket && ticket.id === ticketId) {
              return new Response(JSON.stringify({ success: true, ticket }), {
                headers: { 'Content-Type': 'application/json' }
              });
            }
          }

          return new Response(JSON.stringify({ success: false, error: 'تیکت یافت نشد' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // بستن تیکت
      if (url.pathname.match(/^\/api\/admin\/tickets\/(.+)\/close$/) && request.method === 'POST') {
        try {
          const ticketId = url.pathname.split('/')[4];
          const ticketsResult = await safeKV.list('ticket_');
          
          for (const key of ticketsResult.keys) {
            const ticket = await safeKV.get(key.name, 'json');
            if (ticket && ticket.id === ticketId) {
              ticket.status = 'closed';
              ticket.closedAt = Date.now();
              ticket.closedBy = 'admin';
              
              await safeKV.put(key.name, JSON.stringify(ticket));
              
              // اطلاع‌رسانی به کاربر
              const userNotification = `🔒 <b>تیکت بسته شد</b>

🆔 تیکت: <code>${ticket.id}</code>
📝 موضوع: ${ticket.typeName}

✅ تیکت شما توسط پشتیبانی بسته شد
📅 ${formatDateTime(Date.now())}

💬 برای مسائل جدید می‌توانید تیکت جدید ثبت کنید`;

              await sendMessage(ticket.chatId, userNotification, KEYBOARDS.backToSupport);
              
              return new Response(JSON.stringify({ success: true, message: 'تیکت بسته شد' }), {
                headers: { 'Content-Type': 'application/json' }
              });
            }
          }

          return new Response(JSON.stringify({ success: false, error: 'تیکت یافت نشد' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // API Plans Management
      if (url.pathname === '/api/admin/plans') {
        if (request.method === 'GET') {
          try {
            const plans = await getPlans(safeKV);
            return new Response(JSON.stringify({ success: true, plans }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } else if (request.method === 'POST') {
          try {
            const planData = await request.json();
            const plans = await getPlans(safeKV);
            const planId = generatePlanId();
            
            plans[planId] = {
              id: planId,
              ...planData
            };
            
            await savePlans(safeKV, plans);
            
            return new Response(JSON.stringify({ success: true, message: 'پلن اضافه شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ success: false, error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
      }

      // Edit Plan
      if (url.pathname.match(/^\/api\/admin\/plans\/(.+)$/) && request.method === 'PUT') {
        try {
          const planId = url.pathname.split('/').pop();
          const planData = await request.json();
          const plans = await getPlans(safeKV);
          
          if (plans[planId]) {
            plans[planId] = {
              id: planId,
              ...planData
            };
            await savePlans(safeKV, plans);
            
            return new Response(JSON.stringify({ success: true, message: 'پلن ویرایش شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } else {
            return new Response(JSON.stringify({ success: false, error: 'پلن یافت نشد' }), {
              status: 404,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // Delete Plan
      if (url.pathname.match(/^\/api\/admin\/plans\/(.+)$/) && request.method === 'DELETE') {
        try {
          const planId = url.pathname.split('/').pop();
          const plans = await getPlans(safeKV);
          
          if (plans[planId]) {
            delete plans[planId];
            await savePlans(safeKV, plans);
            
            return new Response(JSON.stringify({ success: true, message: 'پلن حذف شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } else {
            return new Response(JSON.stringify({ success: false, error: 'پلن یافت نشد' }), {
              status: 404,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // API Servers Management
      if (url.pathname === '/api/admin/servers') {
        if (request.method === 'GET') {
          try {
            const servers = await getServers(safeKV);
            return new Response(JSON.stringify({ success: true, servers }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } else if (request.method === 'POST') {
          try {
            const serverData = await request.json();
            const servers = await getServers(safeKV);
            const serverId = generateServerId();
            
            // اگر سرور جدید پیش‌فرض است، سایر سرورها را غیرپیش‌فرض کن
            if (serverData.isDefault) {
              Object.values(servers).forEach(server => {
                server.isDefault = false;
              });
            }
            
            servers[serverId] = {
              id: serverId,
              status: 'active',
              ...serverData
            };
            
            await saveServers(safeKV, servers);
            
            return new Response(JSON.stringify({ success: true, message: 'سرور اضافه شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ success: false, error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
      }

      // Delete Server
      if (url.pathname.match(/^\/api\/admin\/servers\/(.+)$/) && request.method === 'DELETE') {
        try {
          const serverId = url.pathname.split('/').pop();
          const servers = await getServers(safeKV);
          
          if (servers[serverId] && !servers[serverId].isDefault) {
            delete servers[serverId];
            await saveServers(safeKV, servers);
            
            return new Response(JSON.stringify({ success: true, message: 'سرور حذف شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } else {
            return new Response(JSON.stringify({ success: false, error: 'نمی‌توان سرور پیش‌فرض را حذف کرد' }), {
              status: 400,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // Test Server
      if (url.pathname.match(/^\/api\/admin\/servers\/(.+)\/test$/) && request.method === 'GET') {
        try {
          const serverId = url.pathname.split('/')[4];
          const servers = await getServers(safeKV);
          const server = servers[serverId];
          
          if (!server) {
            return new Response(JSON.stringify({ success: false, error: 'سرور یافت نشد' }), {
              status: 404,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          const api = new MarzbanAPI(server.baseUrl);
          const loginResult = await api.login(server.username, server.password);
          
          if (loginResult.success) {
            return new Response(JSON.stringify({ success: true, message: 'اتصال موفق' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } else {
            return new Response(JSON.stringify({ success: false, error: loginResult.error }), {
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // API Inbound Settings
      if (url.pathname === '/api/admin/inbound-settings') {
        if (request.method === 'GET') {
          try {
            const settings = await getInboundSettings(safeKV);
            return new Response(JSON.stringify({ success: true, settings }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        } else if (request.method === 'POST') {
          try {
            const { referenceUsername } = await request.json();
            const settings = { referenceUsername };
            
            await saveInboundSettings(safeKV, settings);
            
            return new Response(JSON.stringify({ success: true, message: 'تنظیمات ذخیره شد' }), {
              headers: { 'Content-Type': 'application/json' }
            });
          } catch (error) {
            return new Response(JSON.stringify({ success: false, error: error.message }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
      }

      // تأیید پرداخت
      if (url.pathname === '/api/admin/approve-payment' && request.method === 'POST') {
        try {
          const { orderId } = await request.json();
          const result = await approvePaymentAPI(orderId, safeKV);
          
          return new Response(JSON.stringify(result), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // رد پرداخت
      if (url.pathname === '/api/admin/reject-payment' && request.method === 'POST') {
        try {
          const { orderId } = await request.json();
          const result = await rejectPaymentAPI(orderId, safeKV);
          
          return new Response(JSON.stringify(result), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // تأیید شارژ کیف پول
      if (url.pathname === '/api/admin/approve-charge' && request.method === 'POST') {
        try {
          const { chargeId } = await request.json();
          
          const chargeData = await safeKV.get(`wallet_charge_${chargeId}`, 'json');
          
          if (!chargeData) {
            return new Response(JSON.stringify({ success: false, error: 'شارژ یافت نشد' }), {
              status: 404,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          if (chargeData.status !== 'payment_submitted') {
            return new Response(JSON.stringify({ success: false, error: 'وضعیت شارژ قابل تأیید نیست' }), {
              status: 400,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          // اضافه کردن مبلغ به کیف پول
          const newBalance = await updateWalletBalance(chargeData.chatId, chargeData.amount, safeKV);
          if (newBalance === false) {
            return new Response(JSON.stringify({ success: false, error: 'خطا در افزودن موجودی' }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          // ثبت تراکنش
          await recordWalletTransaction(chargeData.chatId, chargeData.amount, 'charge', `شارژ کیف پول - ${chargeId}`, safeKV);

          // بروزرسانی وضعیت شارژ
          chargeData.status = 'completed';
          chargeData.completedAt = Date.now();
          await safeKV.put(`wallet_charge_${chargeId}`, JSON.stringify(chargeData));

          await safeKV.delete(`user_charge_${chargeData.chatId}`);

          // اطلاع‌رسانی به کاربر
          const userNotification = `✅ <b>شارژ کیف پول تأیید شد!</b>

🆔 شارژ: <code>${chargeId}</code>
💰 مبلغ شارژ: ${formatPrice(chargeData.amount)}
💳 موجودی جدید: ${formatPrice(newBalance)}

🎉 کیف پول شما شارژ شد!

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

          await sendMessage(chargeData.chatId, userNotification, KEYBOARDS.backToWallet);

          return new Response(JSON.stringify({ success: true, message: 'شارژ تأیید شد' }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }

      // رد شارژ کیف پول
      if (url.pathname === '/api/admin/reject-charge' && request.method === 'POST') {
        try {
          const { chargeId } = await request.json();
          
          const chargeData = await safeKV.get(`wallet_charge_${chargeId}`, 'json');
          
          if (!chargeData) {
            return new Response(JSON.stringify({ success: false, error: 'شارژ یافت نشد' }), {
              status: 404,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          chargeData.status = 'rejected';
          chargeData.rejectedAt = Date.now();
          await safeKV.put(`wallet_charge_${chargeId}`, JSON.stringify(chargeData));

          await safeKV.delete(`user_charge_${chargeData.chatId}`);

          const rejectionText = `❌ <b>شارژ تأیید نشد</b>

🆔 شارژ: <code>${chargeId}</code>
💰 مبلغ: ${formatPrice(chargeData.amount)}

🔍 دلایل احتمالی:
• مبلغ کامل نبوده
• شماره کارت اشتباه
• رسید نامعتبر

💬 پشتیبانی: @${PAYMENT_INFO.supportUsername}`;

          const userKeyboard = {
            reply_markup: {
              inline_keyboard: [
                [{ text: '💳 شارژ مجدد', callback_data: 'wallet_charge' }],
                [{ text: '💬 تماس با پشتیبانی', url: `https://t.me/${PAYMENT_INFO.supportUsername}` }]
              ]
            }
          };

          await sendMessage(chargeData.chatId, rejectionText, userKeyboard);

          return new Response(JSON.stringify({ success: true, message: 'شارژ رد شد' }), {
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          return new Response(JSON.stringify({ success: false, error: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
    }

    if (request.method === 'GET') {
      return new Response(`
🌟 ARDISK VPN Sales Bot
        
✅ Status: Online
🛒 Sales System: Active
💳 Payment Processing: Ready
💰 Wallet System: Active
🖥️ Multi-Server Support: Active
⚙️ Admin Panel: Available
🌐 Web Panel: /admin
🕐 Cron Job: /cron/check-expiry
        
📞 Support: @${PAYMENT_INFO.supportUsername}
🔐 Admin Password: Protected
      `, {
        headers: { 'Content-Type': 'text/plain; charset=utf-8' }
      });
    }
    
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }
    
    try {
      const safeKV = new SafeKV(env?.KV_B);
      if (Math.random() < 0.1) {
        safeKV.cleanup();
      }
      const update = await request.json();
      
      console.log('Sales Bot - Received update:', JSON.stringify(update));
      
      // پردازش پیام
      if (update.message) {
        const chatId = update.message.chat.id;
        const text = update.message.text;

        // --- START: CODE MODIFICATION ---
        // اولویت با دستورات اصلی است که باید تمام وضعیت‌های انتظار را لغو کنند
        if (text === '/start' || text === '/menu') {
          await clearUserPendingState(chatId, safeKV);
          await showMainMenu(chatId, null, safeKV);
          return new Response('OK', { status: 200 }); // خروج زودهنگام برای جلوگیری از پردازش بیشتر
        }

          // اضافه کردن این دستور:
        if (text === '/cleancache' && isAdmin(chatId)) {
          safeKV.clearAll();
          await sendMessage(chatId, '✅ Cache پاک شد!');
          return new Response('OK', { status: 200 });
        }
        
        if (text === '/testvpnen' && isAdmin(chatId)) {
          await testVPNSystem(chatId, safeKV);
          return new Response('OK', { status: 200 });
        }
        if (text === '/debugkv' && isAdmin(chatId)) {
          await debugKVServices(chatId, safeKV);
          return new Response('OK', { status: 200 });
        }
        // --- END: CODE MODIFICATION ---

        // بررسی وضعیت‌های در انتظار (بعد از بررسی دستورات اصلی)
        const pendingTicket = await safeKV.get(`pending_ticket_${chatId}`, 'json');
        const pendingReply = await safeKV.get(`pending_reply_${chatId}`, 'json');
        const pendingUserReply = await safeKV.get(`pending_user_reply_${chatId}`, 'json');
        const userOrder = await safeKV.get(`user_order_${chatId}`);
        const userCharge = await safeKV.get(`user_charge_${chatId}`);
        const waitingChargeAmount = await safeKV.get(`waiting_charge_amount_${chatId}`, 'json');
        const waitingUsername = await safeKV.get(`waiting_username_${chatId}`, 'json');
        
        // پردازش رسیدها و فایل‌ها (اولویت دارد)
        if (userOrder && (update.message.photo || update.message.document)) {
          console.log('Processing receipt upload for order:', userOrder);
          await processReceiptUpload(chatId, update.message, safeKV);
        }
        else if (userCharge && (update.message.photo || update.message.document)) {
          console.log('Processing charge receipt upload for charge:', userCharge);
          await processChargeReceiptUpload(chatId, update.message, safeKV);
        }
        // پردازش پیام‌های متنی
        else if (text) {
          if (pendingReply && isAdmin(chatId)) {
            await processAdminReply(chatId, text, safeKV);
          } else if (pendingUserReply) {
            await processUserTicketReply(chatId, text, safeKV);
          } else if (pendingTicket) {
            await processTicketMessage(chatId, text, safeKV);
          } else if (waitingChargeAmount) {
            await processChargeAmount(chatId, text, safeKV);
          } else if (waitingUsername) {
            await processUsernameSearch(chatId, text, safeKV);
          } else {
            // اگر هیچ وضعیت انتظاری وجود ندارد، منوی اصلی را نشان بده
            await showMainMenu(chatId, null, safeKV);
          }
        }
        // اگر هیچ شرطی برقرار نبود
        else {
          console.log('No handler found for this message type');
          await showMainMenu(chatId, null, safeKV);
        }
      }
      
      // پردازش callback query
      if (update.callback_query) {
        const chatId = update.callback_query.message.chat.id;
        const messageId = update.callback_query.message.message_id;
        const data = update.callback_query.data;
        
        console.log('Callback data received:', data);
        
        // پاسخ به callback query برای حذف حالت لودینگ دکمه
        try {
          await fetch(`${TELEGRAM_API}/answerCallbackQuery`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ callback_query_id: update.callback_query.id })
          });
        } catch (e) {
          console.error('Failed to answer callback query:', e);
        }
        
        // --- START: CODE MODIFICATION ---
        // لغو وضعیت انتظار در صورت بازگشت به منوهای اصلی یا شروع عملیات جدید
        const navigationActions = [
            'start', 'support_menu', 'wallet_menu', 'buy_service', 
            'my_services', 'admin_panel', 'cancel_order', 'cancel_charge'
        ];
        if (navigationActions.includes(data)) {
            await clearUserPendingState(chatId, safeKV);
        }
        // --- END: CODE MODIFICATION ---

        // پردازش دستورات - نسخه کامل شده
        if (data === 'start') {
          await showMainMenu(chatId, messageId, safeKV);
        }
        else if (data === 'user_account') {
          await showUserAccount(chatId, messageId, safeKV);
        }
        else if (data === 'wallet_menu') {
          await showWalletMenu(chatId, messageId, safeKV);
        }
        else if (data === 'wallet_balance') {
          await showWalletBalance(chatId, messageId, safeKV);
        }
        else if (data === 'wallet_charge') {
          await showWalletCharge(chatId, messageId, safeKV);
        }
        else if (data === 'upload_charge_receipt') {
          await handleUploadChargeReceipt(chatId, messageId, safeKV);
        }
        else if (data === 'cancel_charge') {
          await editMessage(chatId, messageId, '❌ شارژ لغو شد.', KEYBOARDS.backToWallet);
        }
        else if (data === 'support_menu') {
          await showSupportMenu(chatId, messageId, safeKV);
        }
        else if (data === 'buy_service') {
          await showBuyService(chatId, messageId, safeKV);
        }
        else if (data === 'my_services') {
          await showMyServices(chatId, messageId, safeKV, 1);
        }
        else if (data === 'find_my_service') {
          await showFindMyService(chatId, messageId, safeKV);
        }
        else if (data === 'connection_guide') {
          await showConnectionGuide(chatId, messageId);
        }
        else if (data === 'create_ticket') {
          await showCreateTicket(chatId, messageId, safeKV);
        }
        else if (data === 'my_tickets') {
          await showMyTickets(chatId, messageId, safeKV);
        }
        // در قسمت callback query handlers اضافه کنید:
else if (data === 'debug_clear_service_cache' && isAdmin(chatId)) {
  safeKV.clearServiceCache();
  await editMessage(chatId, messageId, '✅ Service cache پاک شد!', {
    reply_markup: {
      inline_keyboard: [
        [{ text: '📱 تست سرویس‌ها', callback_data: 'my_services' }],
        [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
      ]
    }
  });
}
else if (data === 'debug_clear_all_cache' && isAdmin(chatId)) {
  safeKV.clearAll();
  await editMessage(chatId, messageId, '✅ همه cache ها پاک شد!', {
    reply_markup: {
      inline_keyboard: [
        [{ text: '📱 تست سرویس‌ها', callback_data: 'my_services' }],
        [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
      ]
    }
  });
}
        else if (data.startsWith('ticket_type_')) {
          const ticketType = data.replace('ticket_type_', '');
          await selectTicketType(chatId, messageId, ticketType, safeKV);
        }
        else if (data.startsWith('view_ticket_')) {
          const ticketId = data.replace('view_ticket_', '');
          await showTicketDetails(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('reply_ticket_user_')) {
          const ticketId = data.replace('reply_ticket_user_', '');
          await userReplyTicket(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('renew_with_plan|')) {
          const parts = data.split('|');
          const serviceId = parts[1];
          const planId = parts[2];
          await processRenewalWithPlan(chatId, messageId, serviceId, planId, safeKV);
        }
        else if (data.startsWith('renew_wallet|')) {
          const parts = data.split('|');
          const serviceId = parts[1];
          const planId = parts[2];
          await renewWithWallet(chatId, messageId, serviceId, planId, safeKV);
        }
        else if (data === 'faq') {
          await showFAQ(chatId, messageId);
        }
        else if (data.startsWith('renew_card|')) {
          const parts = data.split('|');
          const serviceId = parts[1];
          const planId = parts[2];
          await renewWithCard(chatId, messageId, serviceId, planId, safeKV);
        }
        else if (data.startsWith('close_ticket_user_')) {
          const ticketId = data.replace('close_ticket_user_', '');
          await closeTicketByUser(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('reply_ticket_') && isAdmin(chatId)) {
          const ticketId = data.replace('reply_ticket_', '');
          await adminReplyTicket(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('close_ticket_') && isAdmin(chatId)) {
          const ticketId = data.replace('close_ticket_', '');
          await closeTicketByAdmin(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('select_plan_')) {
          const planId = data.replace('select_plan_', '');
          await showPlanDetails(chatId, messageId, planId, safeKV);
        }
        else if (data === 'proceed_payment') {
          await showPaymentMethod(chatId, messageId, safeKV);
        }
        else if (data === 'pay_with_wallet') {
          await payWithWallet(chatId, messageId, safeKV);
        }
        else if (data === 'pay_with_card') {
          await showCardPaymentStep(chatId, messageId, safeKV);
        }
        else if (data === 'upload_receipt') {
          await handleUploadReceipt(chatId, messageId, safeKV);
        }
        else if (data.startsWith('manage_service_')) {
          const serviceId = data.replace('manage_service_', '');
          console.log('Managing service with extracted ID:', serviceId);
          await showServiceManagement(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('renew_service_')) {
          const serviceId = data.replace('renew_service_', '');
          console.log('Renewing service with extracted ID:', serviceId);
          await showServiceRenewal(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('service_status_')) {
          const serviceId = data.replace('service_status_', '');
          console.log('Showing status for service ID:', serviceId);
          await showServiceStatus(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('traffic_usage_')) {
          const serviceId = data.replace('traffic_usage_', '');
          console.log('Showing traffic for service ID:', serviceId);
          await showServiceStatus(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('toggle_service_')) {
          const serviceId = data.replace('toggle_service_', '');
          console.log('Toggling service with ID:', serviceId);
          await toggleServiceStatus(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('reset_link_')) {
          const serviceId = data.replace('reset_link_', '');
          console.log('Reset link confirmation for service ID:', serviceId);
          await showResetLinkConfirmation(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('confirm_reset_')) {
          const serviceId = data.replace('confirm_reset_', '');
          console.log('Confirming reset link for service ID:', serviceId);
          await processResetLink(chatId, messageId, serviceId, safeKV);
        }
        else if (data.startsWith('approve_payment_') && isAdmin(chatId)) {
          const orderId = data.replace('approve_payment_', '');
          await approvePayment(chatId, messageId, orderId, safeKV);
        }
        else if (data.startsWith('services_page_')) {
          const page = parseInt(data.replace('services_page_', ''));
          await showMyServices(chatId, messageId, safeKV, page);
        }
        else if (data === 'current_page') {
          // این دکمه کاری انجام نمی‌دهد، فقط برای نمایش است
        }
        else if (data.startsWith('reject_payment_') && isAdmin(chatId)) {
          const orderId = data.replace('reject_payment_', '');
          await rejectPaymentByAdmin(chatId, messageId, orderId, safeKV);
        }
        else if (data.startsWith('approve_charge_') && isAdmin(chatId)) {
          const chargeId = data.replace('approve_charge_', '');
          await approveCharge(chatId, messageId, chargeId, safeKV);
        }
        else if (data.startsWith('reject_charge_') && isAdmin(chatId)) {
          const chargeId = data.replace('reject_charge_', '');
          await rejectCharge(chatId, messageId, chargeId, safeKV);
        }
        // جابجایی پلن به بالا
else if (data.startsWith('move_plan_up_') && isAdmin(chatId)) {
  const planId = data.replace('move_plan_up_', '');
  const result = await reorderPlans(planId, 'up', safeKV);
  
  if (result.success) {
    // بروزرسانی فوری صفحه
    const plans = await getPlans(safeKV);
    const sortedPlans = getSortedPlans(plans);
    
    let plansText = `📦 <b>مدیریت پلن‌ها</b>

📋 <b>پلن‌های فعال:</b> ${Object.keys(plans).length} عدد

`;

    const plansKeyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    sortedPlans.forEach((plan, index) => {
      plansText += `${index + 1}. <b>${plan.name}</b>
💰 قیمت: ${formatPrice(plan.price)}
⏰ مدت: ${plan.duration} روز
📊 حجم: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}

`;

      const moveButtons = [];
      if (index > 0) {
        moveButtons.push({ text: '⬆️', callback_data: `move_plan_up_${plan.id}` });
      }
      if (index < sortedPlans.length - 1) {
        moveButtons.push({ text: '⬇️', callback_data: `move_plan_down_${plan.id}` });
      }
      
      plansKeyboard.reply_markup.inline_keyboard.push([
        ...moveButtons,
        { text: `✏️ ${plan.name}`, callback_data: `edit_plan_${plan.id}` }
      ]);
    });

    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '➕ افزودن پلن', callback_data: 'admin_add_plan' }
    ]);
    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '🧪 تست پلن‌ها', callback_data: 'admin_test_plans' }
    ]);
    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
    ]);

    await editMessage(chatId, messageId, plansText, plansKeyboard);
  } else {
    // نمایش خطا
    await editMessage(chatId, messageId, `❌ خطا: ${result.error}`, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔙 بازگشت', callback_data: 'admin_plans' }]
        ]
      }
    });
  }
}

// جابجایی پلن به پایین  
else if (data.startsWith('move_plan_down_') && isAdmin(chatId)) {
  const planId = data.replace('move_plan_down_', '');
  const result = await reorderPlans(planId, 'down', safeKV);
  
  if (result.success) {
    // بروزرسانی فوری صفحه (همان کد بالا)
    const plans = await getPlans(safeKV);
    const sortedPlans = getSortedPlans(plans);
    
    let plansText = `📦 <b>مدیریت پلن‌ها</b>

📋 <b>پلن‌های فعال:</b> ${Object.keys(plans).length} عدد

`;

    const plansKeyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    sortedPlans.forEach((plan, index) => {
      plansText += `${index + 1}. <b>${plan.name}</b>
💰 قیمت: ${formatPrice(plan.price)}
⏰ مدت: ${plan.duration} روز
📊 حجم: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}

`;

      const moveButtons = [];
      if (index > 0) {
        moveButtons.push({ text: '⬆️', callback_data: `move_plan_up_${plan.id}` });
      }
      if (index < sortedPlans.length - 1) {
        moveButtons.push({ text: '⬇️', callback_data: `move_plan_down_${plan.id}` });
      }
      
      plansKeyboard.reply_markup.inline_keyboard.push([
        ...moveButtons,
        { text: `✏️ ${plan.name}`, callback_data: `edit_plan_${plan.id}` }
      ]);
    });

    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '➕ افزودن پلن', callback_data: 'admin_add_plan' }
    ]);
    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
    ]);

    await editMessage(chatId, messageId, plansText, plansKeyboard);
  } else {
    await editMessage(chatId, messageId, `❌ خطا: ${result.error}`, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔙 بازگشت', callback_data: 'admin_plans' }]
        ]
      }
    });
  }
}
        else if (data === 'admin_panel' && isAdmin(chatId)) {
          const adminText = `⚙️ <b>پنل مدیریت ARDISK VPN</b>

        🔧 <b>ابزارهای مدیریت سیستم</b>

        انتخاب کنید:`;

          const adminKeyboard = {
            reply_markup: {
              inline_keyboard: [
                [
                  { text: '📊 آمار سیستم', callback_data: 'admin_stats' },
                  { text: '💳 پرداخت‌ها', callback_data: 'admin_payments' }
                ],
                [
                  { text: '🎫 تیکت‌ها', callback_data: 'admin_tickets' },
                  { text: '👥 کاربران', callback_data: 'admin_users' }
                ],
                [
                  { text: '📦 مدیریت پلن‌ها', callback_data: 'admin_plans' },
                  { text: '🖥️ مدیریت سرورها', callback_data: 'admin_servers' }
                ],
                [
                  { text: '⚙️ تنظیمات', callback_data: 'admin_settings' }
                ],
                [
                  { text: '🔙 منوی اصلی', callback_data: 'start' }
                ]
              ]
            }
          };

          await editMessage(chatId, messageId, adminText, adminKeyboard);
        }
        else if (data === 'admin_stats' && isAdmin(chatId)) {
          try {
            await editMessage(chatId, messageId, '⏳ در حال محاسبه آمار...', {});
            
            const revenue = await calculateRevenue(safeKV);
            
            const ordersResult = await safeKV.list('order_ORD_');
            let pendingPayments = 0;
            let totalUsers = new Set();
            
            for (const key of ordersResult.keys.slice(0, 200)) {
              try {
                const order = await safeKV.get(key.name, 'json');
                if (order) {
                  totalUsers.add(order.chatId);
                  if (order.status === 'payment_submitted') {
                    pendingPayments++;
                  }
                }
              } catch (e) {}
            }
            
            const servicesResult = await safeKV.list('service_');
            let activeServices = 0;
            let expiredServices = 0;
            const now = Date.now();
            
            for (const key of servicesResult.keys.slice(0, 100)) {
              try {
                const service = await safeKV.get(key.name, 'json');
                if (service) {
                  if (service.expireTimestamp > now) {
                    activeServices++;
                  } else {
                    expiredServices++;
                  }
                }
              } catch (e) {}
            }
            
            const ticketsResult = await safeKV.list('ticket_');
            let openTickets = 0;
            for (const key of ticketsResult.keys.slice(0, 50)) {
              try {
                const ticket = await safeKV.get(key.name, 'json');
                if (ticket && ticket.status === 'open') {
                  openTickets++;
                }
              } catch (e) {}
            }

            const statsText = `📊 <b>آمار کامل سیستم</b>

        💰 <b>درآمد:</b>
        • امروز: ${formatPrice(revenue.todayRevenue)}
        • کل: ${formatPrice(revenue.totalRevenue)}

        🛒 <b>سفارش‌ها:</b>
        • امروز: ${revenue.todayOrders} عدد
        • در انتظار: ${pendingPayments} عدد

        👥 <b>کاربران:</b>
        • کل: ${totalUsers.size} نفر

        📱 <b>سرویس‌ها:</b>
        • فعال: ${activeServices} عدد
        • منقضی: ${expiredServices} عدد

        🎫 <b>تیکت‌ها:</b>
        • باز: ${openTickets} عدد

        🕐 <b>آخرین بروزرسانی:</b> ${formatDateTime(Date.now())}`;

            const statsKeyboard = {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: '🔄 بروزرسانی', callback_data: 'admin_stats' }
                  ],
                  [
                    { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
                  ]
                ]
              }
            };

            await editMessage(chatId, messageId, statsText, statsKeyboard);
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در دریافت آمار', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
                ]
              }
            });
          }
        }
        else if (data === 'admin_payments' && isAdmin(chatId)) {
          try {
            await editMessage(chatId, messageId, '⏳ در حال بارگیری پرداخت‌ها...', {});
            
            const ordersResult = await safeKV.list('order_ORD_');
            const pendingPayments = [];
            const chargesResult = await safeKV.list('wallet_charge_');
            const pendingCharges = [];

            for (const key of ordersResult.keys.slice(0, 50)) {
              try {
                const order = await safeKV.get(key.name, 'json');
                if (order && order.status === 'payment_submitted') {
                  pendingPayments.push(order);
                }
              } catch (e) {}
            }

            for (const key of chargesResult.keys.slice(0, 20)) {
              try {
                const charge = await safeKV.get(key.name, 'json');
                if (charge && charge.status === 'payment_submitted') {
                  pendingCharges.push(charge);
                }
              } catch (e) {}
            }

            let paymentsText = `💳 <b>مدیریت پرداخت‌ها</b>

        🔴 <b>در انتظار تأیید:</b> ${pendingPayments.length + pendingCharges.length} مورد

        `;

            const paymentsKeyboard = {
              reply_markup: {
                inline_keyboard: []
              }
            };

            if (pendingPayments.length > 0) {
              paymentsText += `\n🛒 <b>سفارش‌ها (${pendingPayments.length}):</b>\n`;
              
              pendingPayments.slice(0, 8).forEach((payment, index) => {
                paymentsText += `${index + 1}. ${payment.plan.name} - ${formatPrice(payment.plan.price)}\n`;
                paymentsKeyboard.reply_markup.inline_keyboard.push([{
                  text: `✅ تأیید سفارش ${index + 1}`,
                  callback_data: `admin_approve_${payment.id}`
                }, {
                  text: `❌ رد ${index + 1}`,
                  callback_data: `admin_reject_${payment.id}`
                }]);
              });
            }

            if (pendingCharges.length > 0) {
              paymentsText += `\n💰 <b>شارژ کیف پول (${pendingCharges.length}):</b>\n`;
              
              pendingCharges.slice(0, 5).forEach((charge, index) => {
                paymentsText += `${index + 1}. شارژ ${formatPrice(charge.amount)}\n`;
                paymentsKeyboard.reply_markup.inline_keyboard.push([{
                  text: `✅ تأیید شارژ ${index + 1}`,
                  callback_data: `admin_approve_charge_${charge.id}`
                }, {
                  text: `❌ رد شارژ ${index + 1}`,
                  callback_data: `admin_reject_charge_${charge.id}`
                }]);
              });
            }

            if (pendingPayments.length === 0 && pendingCharges.length === 0) {
              paymentsText += '✅ هیچ پرداخت در انتظاری وجود ندارد!';
            }

            paymentsKeyboard.reply_markup.inline_keyboard.push([
              { text: '🔄 بروزرسانی', callback_data: 'admin_payments' }
            ]);
            paymentsKeyboard.reply_markup.inline_keyboard.push([
              { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
            ]);

            await editMessage(chatId, messageId, paymentsText, paymentsKeyboard);
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در بارگیری پرداخت‌ها', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
                ]
              }
            });
          }
        }
        else if (data === 'admin_tickets' && isAdmin(chatId)) {
          try {
            await editMessage(chatId, messageId, '⏳ در حال بارگیری تیکت‌ها...', {});
            
            const ticketsResult = await safeKV.list('ticket_');
            const openTickets = [];
            const recentClosed = [];

            for (const key of ticketsResult.keys.slice(0, 50)) {
              try {
                const ticket = await safeKV.get(key.name, 'json');
                if (ticket) {
                  if (ticket.status === 'open') {
                    openTickets.push(ticket);
                  } else if (ticket.closedAt && Date.now() - ticket.closedAt < 7 * 24 * 60 * 60 * 1000) {
                    recentClosed.push(ticket);
                  }
                }
              } catch (e) {}
            }

            let ticketsText = `🎫 <b>مدیریت تیکت‌ها</b>

        🟢 <b>تیکت‌های باز:</b> ${openTickets.length} عدد
        🔴 <b>بسته شده (7 روز اخیر):</b> ${recentClosed.length} عدد

        `;

            const ticketsKeyboard = {
              reply_markup: {
                inline_keyboard: []
              }
            };

            if (openTickets.length > 0) {
              ticketsText += '\n🟢 <b>تیکت‌های باز:</b>\n';
              
              openTickets.slice(0, 8).forEach((ticket, index) => {
                ticketsText += `${index + 1}. ${ticket.typeName} - کاربر: ${ticket.chatId}\n`;
                ticketsKeyboard.reply_markup.inline_keyboard.push([{
                  text: `👁️ مشاهده تیکت ${index + 1}`,
                  callback_data: `admin_view_ticket_${ticket.id}`
                }]);
              });
            } else {
              ticketsText += '✅ هیچ تیکت بازی وجود ندارد!';
            }

            ticketsKeyboard.reply_markup.inline_keyboard.push([
              { text: '🔄 بروزرسانی', callback_data: 'admin_tickets' }
            ]);
            ticketsKeyboard.reply_markup.inline_keyboard.push([
              { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
            ]);

            await editMessage(chatId, messageId, ticketsText, ticketsKeyboard);
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در بارگیری تیکت‌ها', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
                ]
              }
            });
          }
        }
        else if (data === 'admin_users' && isAdmin(chatId)) {
          try {
            await editMessage(chatId, messageId, '⏳ در حال بارگیری کاربران...', {});
            
            const users = new Map();
            
            const servicesResult = await safeKV.list('service_');
            for (const key of servicesResult.keys.slice(0, 100)) {
              try {
                const service = await safeKV.get(key.name, 'json');
                if (service && service.chatId) {
                  if (!users.has(service.chatId)) {
                    users.set(service.chatId, {
                      chatId: service.chatId,
                      services: 0,
                      orders: 0,
                      totalPaid: 0,
                      lastActivity: 0
                    });
                  }
                  users.get(service.chatId).services++;
                  users.get(service.chatId).lastActivity = Math.max(
                    users.get(service.chatId).lastActivity,
                    service.createdAt
                  );
                }
              } catch (e) {}
            }
            
            const ordersResult = await safeKV.list('order_ORD_');
            for (const key of ordersResult.keys.slice(0, 200)) {
              try {
                const order = await safeKV.get(key.name, 'json');
                if (order && order.chatId) {
                  if (!users.has(order.chatId)) {
                    users.set(order.chatId, {
                      chatId: order.chatId,
                      services: 0,
                      orders: 0,
                      totalPaid: 0,
                      lastActivity: 0
                    });
                  }
                  users.get(order.chatId).orders++;
                  if (order.status === 'completed') {
                    users.get(order.chatId).totalPaid += order.plan.price;
                  }
                  users.get(order.chatId).lastActivity = Math.max(
                    users.get(order.chatId).lastActivity,
                    order.createdAt
                  );
                }
              } catch (e) {}
            }

            const topUsers = Array.from(users.values())
              .sort((a, b) => b.totalPaid - a.totalPaid)
              .slice(0, 15);

            let usersText = `👥 <b>مدیریت کاربران</b>

        📊 <b>کل کاربران:</b> ${users.size} نفر

        💎 <b>برترین کاربران:</b>

        `;

            topUsers.forEach((user, index) => {
              usersText += `${index + 1}. کاربر: <code>${user.chatId}</code>
        💰 پرداخت: ${formatPrice(user.totalPaid)}
        📱 سرویس: ${user.services} | 🛒 سفارش: ${user.orders}

        `;
            });

            const usersKeyboard = {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: '🔄 بروزرسانی', callback_data: 'admin_users' }
                  ],
                  [
                    { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
                  ]
                ]
              }
            };

            await editMessage(chatId, messageId, usersText, usersKeyboard);
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در بارگیری کاربران', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
                ]
              }
            });
          }
        }
        // در قسمت callback query handlers جایگزین کن:
else if (data === 'admin_plans' && isAdmin(chatId)) {
  try {
    const plans = await getPlans(safeKV);
    const sortedPlans = getSortedPlans(plans);
    
    let plansText = `📦 <b>مدیریت پلن‌ها</b>

📋 <b>پلن‌های فعال:</b> ${Object.keys(plans).length} عدد

`;

    const plansKeyboard = {
      reply_markup: {
        inline_keyboard: []
      }
    };

    sortedPlans.forEach((plan, index) => {
      plansText += `${index + 1}. <b>${plan.name}</b>
💰 قیمت: ${formatPrice(plan.price)}
⏰ مدت: ${plan.duration} روز
📊 حجم: ${plan.dataLimit ? plan.dataLimit + ' گیگ' : 'نامحدود'}

`;

      // دکمه‌های جابجایی
      const moveButtons = [];
      if (index > 0) {
        moveButtons.push({ text: '⬆️', callback_data: `move_plan_up_${plan.id}` });
      }
      if (index < sortedPlans.length - 1) {
        moveButtons.push({ text: '⬇️', callback_data: `move_plan_down_${plan.id}` });
      }
      
      plansKeyboard.reply_markup.inline_keyboard.push([
        ...moveButtons,
        { text: `✏️ ${plan.name}`, callback_data: `edit_plan_${plan.id}` }
      ]);
    });

    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '➕ افزودن پلن', callback_data: 'admin_add_plan' }
    ]);
    plansKeyboard.reply_markup.inline_keyboard.push([
      { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
    ]);

    await editMessage(chatId, messageId, plansText, plansKeyboard);
  } catch (error) {
    await editMessage(chatId, messageId, '❌ خطا در بارگیری پلن‌ها', {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
        ]
      }
    });
  }
}

else if (data === 'admin_test_plans' && isAdmin(chatId)) {
  await initializePlanOrders(safeKV);
  const plans = await getPlans(safeKV);
  
  let testText = `🧪 <b>تست پلن‌ها</b>

`;
  
  Object.values(plans).forEach(plan => {
    testText += `📋 ${plan.name} - Order: ${plan.order || 'ندارد'}\n`;
  });
  
  const testKeyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: '🔧 اولیه‌سازی Order', callback_data: 'init_plan_orders' }],
        [{ text: '📦 بازگشت به پلن‌ها', callback_data: 'admin_plans' }]
      ]
    }
  };
  
  await editMessage(chatId, messageId, testText, testKeyboard);
}

// اولیه‌سازی دستی
else if (data === 'init_plan_orders' && isAdmin(chatId)) {
  const result = await initializePlanOrders(safeKV);
  
  if (result.success) {
    await editMessage(chatId, messageId, '✅ Order پلن‌ها اولیه‌سازی شد!', {
      reply_markup: {
        inline_keyboard: [
          [{ text: '📦 مشاهده پلن‌ها', callback_data: 'admin_plans' }]
        ]
      }
    });
  } else {
    await editMessage(chatId, messageId, `❌ خطا: ${result.error}`, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '🔙 بازگشت', callback_data: 'admin_plans' }]
        ]
      }
    });
  }
}

        else if (data === 'admin_servers' && isAdmin(chatId)) {
          try {
            const servers = await getServers(safeKV);
            
            let serversText = `🖥️ <b>مدیریت سرورها</b>

        🖥️ <b>سرورهای فعال:</b> ${Object.keys(servers).length} عدد

        `;

            Object.values(servers).forEach((server, index) => {
              serversText += `${index + 1}. <b>${server.name}</b> ${server.isDefault ? '⭐' : ''}
        🌍 موقعیت: ${server.location}
        📊 وضعیت: ${server.status === 'active' ? 'فعال ✅' : 'غیرفعال ❌'}

        `;
            });

            const serversKeyboard = {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: '➕ افزودن سرور', callback_data: 'admin_add_server' }
                  ],
                  [
                    { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
                  ]
                ]
              }
            };

            await editMessage(chatId, messageId, serversText, serversKeyboard);
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در بارگیری سرورها', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }]
                ]
              }
            });
          }
        }
        else if (data === 'admin_settings' && isAdmin(chatId)) {
          const settingsText = `⚙️ <b>تنظیمات سیستم</b>

        🔧 <b>تنظیمات فعلی:</b>

        💳 <b>اطلاعات پرداخت:</b>
        • کارت: <code>${PAYMENT_INFO.cardNumber}</code>
        • نام: ${PAYMENT_INFO.cardHolder}
        • پشتیبانی: @${PAYMENT_INFO.supportUsername}

        🎯 <b>عملیات:</b>`;

          const settingsKeyboard = {
            reply_markup: {
              inline_keyboard: [
                [
                  { text: '🔄 ریست کش', callback_data: 'admin_clear_cache' }
                ],
                [
                  { text: '📊 پشتیبان‌گیری', callback_data: 'admin_backup' }
                ],
                [
                  { text: '🔙 پنل مدیریت', callback_data: 'admin_panel' }
                ]
              ]
            }
          };

          await editMessage(chatId, messageId, settingsText, settingsKeyboard);
        }
        else if (data.startsWith('admin_approve_') && isAdmin(chatId)) {
          const orderId = data.replace('admin_approve_', '');
          await approvePayment(chatId, messageId, orderId, safeKV);
        }
        else if (data.startsWith('admin_reject_') && isAdmin(chatId)) {
          const orderId = data.replace('admin_reject_', '');
          await rejectPaymentByAdmin(chatId, messageId, orderId, safeKV);
        }
        else if (data.startsWith('admin_approve_charge_') && isAdmin(chatId)) {
          const chargeId = data.replace('admin_approve_charge_', '');
          await approveCharge(chatId, messageId, chargeId, safeKV);
        }
        else if (data === 'admin_clear_cache' && isAdmin(chatId)) {
          try {
            safeKV.clearAll();
            
            await editMessage(chatId, messageId, '✅ <b>Cache پاک شد!</b>\n\n🔄 سیستم بهینه‌سازی شد\n⚡ عملکرد بهبود یافت', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 تنظیمات', callback_data: 'admin_settings' }]
                ]
              }
            });
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در پاک کردن cache!', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 تنظیمات', callback_data: 'admin_settings' }]
                ]
              }
            });
          }
        }
        else if (data.startsWith('admin_reject_charge_') && isAdmin(chatId)) {
          const chargeId = data.replace('admin_reject_charge_', '');
          await rejectCharge(chatId, messageId, chargeId, safeKV);
        }
        else if (data.startsWith('admin_view_ticket_') && isAdmin(chatId)) {
          const ticketId = data.replace('admin_view_ticket_', '');
          
          try {
            const ticketsResult = await safeKV.list('ticket_');
            let ticketData = null;
            
            for (const key of ticketsResult.keys) {
              const ticket = await safeKV.get(key.name, 'json');
              if (ticket && ticket.id === ticketId) {
                ticketData = ticket;
                break;
              }
            }

            if (ticketData) {
              let ticketText = `🎫 <b>جزئیات تیکت</b>

        🆔 شماره: <code>${ticketData.id}</code>
        👤 کاربر: <code>${ticketData.chatId}</code>
        📝 موضوع: ${ticketData.typeName}
        📅 تاریخ: ${formatDate(ticketData.createdAt)}
        🔸 وضعیت: ${ticketData.status === 'open' ? '🟢 باز' : '🔴 بسته'}

        📄 <b>پیام اصلی:</b>
        ${ticketData.message}

        💬 <b>پیام‌ها:</b> ${ticketData.messages.length} عدد`;

              const ticketKeyboard = {
                reply_markup: {
                  inline_keyboard: [
                    [
                      { text: '💬 پاسخ دادن', callback_data: `admin_reply_ticket_${ticketId}` },
                      { text: '🔒 بستن تیکت', callback_data: `admin_close_ticket_${ticketId}` }
                    ],
                    [
                      { text: '🔙 لیست تیکت‌ها', callback_data: 'admin_tickets' }
                    ]
                  ]
                }
              };

              await editMessage(chatId, messageId, ticketText, ticketKeyboard);
            } else {
              await editMessage(chatId, messageId, '❌ تیکت یافت نشد!', {
                reply_markup: {
                  inline_keyboard: [
                    [{ text: '🔙 لیست تیکت‌ها', callback_data: 'admin_tickets' }]
                  ]
                }
              });
            }
          } catch (error) {
            await editMessage(chatId, messageId, '❌ خطا در نمایش تیکت', {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 لیست تیکت‌ها', callback_data: 'admin_tickets' }]
                ]
              }
            });
          }
        }
        else if (data.startsWith('admin_close_ticket_') && isAdmin(chatId)) {
          const ticketId = data.replace('admin_close_ticket_', '');
          await closeTicketByAdmin(chatId, messageId, ticketId, safeKV);
        }
        else if (data.startsWith('get_config_')) {
          const serviceId = data.replace('get_config_', '');
          console.log('Getting config for service ID:', serviceId);
          await showServiceManagement(chatId, messageId, serviceId, safeKV, true);
        }
        else if (data === 'cancel_order') {
          await editMessage(chatId, messageId, '❌ سفارش لغو شد.', KEYBOARDS.backToMain);
        }
        else if (data === 'admin_retest_system' && isAdmin(chatId)) {
          await testVPNSystem(chatId, safeKV);
        }
        else if (data === 'admin_force_cron' && isAdmin(chatId)) {
          await forceRunCronJob(chatId, messageId, safeKV);
        }
        else if (data === 'admin_full_test' && isAdmin(chatId)) {
          await testVPNSystem(chatId, safeKV);
        }
        else if (data === 'test_received' && isAdmin(chatId)) {
          await editMessage(chatId, messageId, '✅ تست اطلاع‌رسانی موفقیت‌آمیز بود!', {
            reply_markup: {
              inline_keyboard: [
                [{ text: '🏠 منوی اصلی', callback_data: 'start' }]
              ]
            }
          });
        }
      }
      
      return new Response('OK', { status: 200 });
      
    } catch (error) {
      console.error('Sales Bot Worker Error:', error);
      // در صورت بروز خطا، یک پاسخ موفقیت‌آمیز به تلگرام برگردانید تا از تلاش‌های مجدد جلوگیری شود
      return new Response('Error processed', { status: 200 });
    }
  },

  // Cron Job برای بررسی انقضای سرویس‌ها - هر 10 دقیقه
  async scheduled(controller, env, ctx) {
    const safeKV = new SafeKV(env?.KV_B);
    
    // اجرای cron job هر 10 دقیقه
    if (controller.cron === "*/10 * * * *") {
      try {
        console.log('Starting scheduled expiry check...');
        await checkExpiringServices(safeKV);
        console.log('Scheduled expiry check finished.');
      } catch (error) {
        console.error('Error during scheduled task:', error);
      }
    }
  }
};
